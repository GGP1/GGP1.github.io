<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Applications containerization | Gastón Palomeque</title>
<meta name=keywords content>
<meta name=description content="The concept of containerization was first introduced in 1979 during the development of chroot (Version 7 Unix), which restricted an application&rsquo;s file access to a specific directory - the root - and its children.
The main benefit chroot brought in was process isolation, improving the system security such that an internal vulnerability wouldn&rsquo;t affect external systems.
In fact, chroot was the first of a series of technologies designed to protect each process from the others on the operating system.">
<meta name=author content>
<link rel=canonical href=https://ggp1.github.io/posts/applications_containerization/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.15f3f69b5a510ba11e60d2a099f0f25695a8b6148a1422fb5ef6e357d5f8c47c.css integrity="sha256-FfP2m1pRC6EeYNKgmfDyVpWothSKFCL7XvbjV9X4xHw=" rel="preload stylesheet" as=style>
<link rel=preload href=/apple-touch-icon.png as=image>
<link rel=icon href=https://ggp1.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://ggp1.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://ggp1.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://ggp1.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://ggp1.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<meta property="og:title" content="Applications containerization">
<meta property="og:description" content="The concept of containerization was first introduced in 1979 during the development of chroot (Version 7 Unix), which restricted an application&rsquo;s file access to a specific directory - the root - and its children.
The main benefit chroot brought in was process isolation, improving the system security such that an internal vulnerability wouldn&rsquo;t affect external systems.
In fact, chroot was the first of a series of technologies designed to protect each process from the others on the operating system.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ggp1.github.io/posts/applications_containerization/">
<meta property="og:image" content="https://ggp1.github.io/images/containers.jpg"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-10-20T00:00:00+00:00">
<meta property="article:modified_time" content="2021-10-20T00:00:00+00:00"><meta property="og:site_name" content="Gastón Palomeque">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://ggp1.github.io/images/containers.jpg">
<meta name=twitter:title content="Applications containerization">
<meta name=twitter:description content="The concept of containerization was first introduced in 1979 during the development of chroot (Version 7 Unix), which restricted an application&rsquo;s file access to a specific directory - the root - and its children.
The main benefit chroot brought in was process isolation, improving the system security such that an internal vulnerability wouldn&rsquo;t affect external systems.
In fact, chroot was the first of a series of technologies designed to protect each process from the others on the operating system.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ggp1.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Applications containerization","item":"https://ggp1.github.io/posts/applications_containerization/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Applications containerization","name":"Applications containerization","description":"The concept of containerization was first introduced in 1979 during the development of chroot (Version 7 Unix), which restricted an application\u0026rsquo;s file access to a specific directory - the root - and its children.\nThe main benefit chroot brought in was process isolation, improving the system security such that an internal vulnerability wouldn\u0026rsquo;t affect external systems.\nIn fact, chroot was the first of a series of technologies designed to protect each process from the others on the operating system.","keywords":[],"articleBody":"The concept of containerization was first introduced in 1979 during the development of chroot (Version 7 Unix), which restricted an application’s file access to a specific directory - the root - and its children.\nThe main benefit chroot brought in was process isolation, improving the system security such that an internal vulnerability wouldn’t affect external systems.\nIn fact, chroot was the first of a series of technologies designed to protect each process from the others on the operating system.\nMore than two decades later, in 2002, a feature called namespaces was included into the Linux kernel.\nNamespaces partition kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources.\nFive years later, engineers at Google released cgroups, another feature that was added to the Linux kernel and that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes.\nThe two last are the main features that the Docker Inc. took advantage of when creating the Docker Engine container runtime in 2013, since then, containers have gained more and more adoption in the software industry all around the world.\nContainers Containers encapsulate the code, libraries and configurations necessary to run an application, they offer process-level isolation and share the kernel of the host operating system with other containers.\n While running in isolated processes could prevent malicious code from one container to impact others running in the same server, if there is a vulnerability in the kernel that would affect all of them indistinctively, as opposed to virtual machines that provide hardware-level isolation.\n The fact that they do not require an operating system per container makes them lightweight, portable and inexpensive.\n    Docker containers running in one machine    Multiple containers can be created easily and fast in any machine running the Docker Engine.\nLike virtual machines, they are already set up and ready for the application to run, providing a consistent solution and saving a lot of time to developers.\nApplication We will use the following super simple server written in Go to demonstrate how to containerize applications efficiently:\npackage main import ( \"net/http\" \"fmt\" \"log\" ) func main() { http.HandleFunc(\"/\", home) if err := http.ListenAndServe(\":3000\", nil); err != nil { log.Fatal(err) } } func home(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \"Hello world\") } The docker image we are going to build is more or less similar to the ones you would use in any other compiled language so, without further ado, let’s start.\nDockerfile We will start off with a naive image, improving it along the way and explaning the improvements.\nThe directory we are using has the following structure\n└── app ├── main.go ├── Dockerfile └── go.mod and the initial Dockerfile looks like\n# Start from an image with the Go language and its dependencies installed FROMgolang:latest # Move into the \"/app\" directory (it's created if not exists) WORKDIR/app # Copy everything inside the host's current directory into the image's \"/app\"  # directory (\".\" means current directory) # COPY  COPY . . # Compile server and put the binary inside the image's current directory,  # thus it will be at \"/app/server\" # go build -o  RUN go build -o server # When the image is run in a container, execute the binary CMD [\"/app/server\"] Having the image specification done we only have to move into the directory containing the file and build it executing docker build -t server ., here’s the result:\n    Basic image    To run the image inside a container and expose our server execute docker run -p 3000:3000 server.\n The -t flag takes the image’s tag name: -t .\nThe -p flag publishes a container’s port to the host: -p :.\n Perfect, our server is up and running, we’re done! Well, not so fast, we can do it much better.\nImage versioning In our first example we didn’t specify the version of the image we started from, if the Go team releases a new version with breaking changes our application will be built from it and potentially break.\nTo fix this, we can visit the Go official images on Docker Hub and find a version that suits our needs, in this case I’m going to use the alpine-based version.\n Alpine is minimal Docker image based on Alpine Linux with a complete package index and only 5 MB in size.\n FROMgolang:1.17.1-alpine3.14 With this change only, we are going to avoid broken CI/CD pipelines and save 626 MB of space.\n    1.17.1-alpine3.14 version    The only reason not to start from an alpine image is if it does not support a package/tool that your application requires to build or run.\nModules caching If we were to develop using Docker with the image above, every change we make in the application’s code would leave Docker’s caching layer useless.\nWhen building the image, dependencies are downloaded when the application is compiled (go build -o server) but if we modify a single line of code we change the directory’s content and invalidate Docker’s caching layer, forcing the process to download all the dependencies again.\nIn order to fix this issue, we are going to copy and download the Go modules before any change is introduced (in other languages this may be done differently).\nThe next time the image is built, they will be taken from the cache instead of re-downloaded, unless we add or remove a dependency.\n# Copy the modules file and put it in the container COPY go.mod . # Download modules RUN go mod download # Previously, this step was invalidating the cache COPY . . # Normally it would try to download the modules here but they are now cached RUN go build -o server Removing binary debug flags  This is Go-specific\n The binary size can be reduced by removing the symbol table and DWARF debugging information generation from it.\nRUN go build -o server -ldflags=\"-s -w\" Multi-stage builds Each instruction in the dockerfile adds a layer to the image and creates artifacts for its execution, multi-stage builds allow us to copy artifacts from one stage to another and leave behind those that won’t take part in the final image.\n We are left with the image from the final stage only, the other ones behave like temporary tables/files.\n In other words, they allow us to segmentate the building process in order to get to a final image containing just what we need to run our application, leaving behind the dependencies used for its compilation.\n# ----- First stage ----- # Declare this image as builder FROMgolang:1.17.1-alpine3.14 AS builder WORKDIR/app COPY go.mod . RUN go mod download COPY . . RUN go build -o server -ldflags=\"-s -w\" # ----- Second stage ----- FROMalpine:3.14.2 # Copy the binary from the builder to this image COPY --from=builder /app/server . CMD [\"/server\"]     Multi-stage builds    Voilà! We have reduced the image size from 321MB to just 11.7MB. But this is not the end, let’s see what else can be improved.\nLimited privileges Containers built with the images we just reviewed allow executing commands and can be accessed with root privileges by using docker exec -it  sh.\nThis should be avoided at all cost since an attacker could get to the container and do whatever he pleases with it and its information.\nIf for some reason you need command execution, create a user with limited privileges and switch to it like so:\nFROMalpine:3.14.2 # Set USER and UID environment variables ENV USER= ENV UID= COPY --from=builder /app/server . # Add user and change the binary file ownership and permissions RUN adduser $USER -D -g \"\" -s \"/sbin/nologin\" -u $UID \\  \u0026\u0026 chown $USER /server \\  \u0026\u0026 chmod 0700 /server # Switch to the user created to execute the command as $USER USER$USER CMD [\"/server\"] FROM scratch scratch is Docker’s base image, as of version 1.5.0 is a no-op and it won’t create an extra layer in the image.\nUsing FROM scratch signals to the build process that the next command in the Dockerfile is the first filesystem layer.\nThis image doesn’t have a shell installed so it’s not possible to enter the container and execute commands, increasing the security and reducing the size of the image.\nFROMgolang:1.17.1-alpine3.14 AS builder WORKDIR/app COPY go.mod . RUN go mod download COPY . . RUN CGO_ENABLED=0 go build -o server -ldflags=\"-s -w\" # -------------------- FROMscratch COPY --from=builder /app/server . ENTRYPOINT [\"/server\"]  In Go, it’s necessary to disable CGO (CGO_ENABLED=0) when building from scratch so the executable does not depend on the system C libraries and will embed everything it needs to run.\n     FROM scratch    If you are looking to serve through HTTPS you will have to add the two following lines:\n# First stage RUN apk add --update --no-cache git ca-certificates \u0026\u0026 update-ca-certificates # Second stage COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ Wrapping up In summary, we have covered how to take advantage of image versioning, modules caching, limited privileges and multi-stage builds to deliver reliable, small and secure images.\nFrom now on, we can run our server in any machine with Docker installed, use Kubernetes to orchestrate different copies of it and/or use a cloud provider to let the world consume our services in just a few minutes.\n","wordCount":"1545","inLanguage":"en","image":"https://ggp1.github.io/images/containers.jpg","datePublished":"2021-10-20T00:00:00Z","dateModified":"2021-10-20T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ggp1.github.io/posts/applications_containerization/"},"publisher":{"@type":"Organization","name":"Gastón Palomeque","logo":{"@type":"ImageObject","url":"https://ggp1.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://ggp1.github.io/ accesskey=h title=" (Alt + H)">
<img src=/apple-touch-icon.png alt=logo aria-label=logo height=38></a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://ggp1.github.io/ title=home>
<span>home</span>
</a>
</li>
<li>
<a href=https://ggp1.github.io/projects/ title=projects>
<span>projects</span>
</a>
</li>
<li>
<a href=https://ggp1.github.io/posts/ title=posts>
<span>posts</span>
</a>
</li>
<li>
<a href=https://ggp1.github.io/about/ title=about>
<span>about</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://ggp1.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ggp1.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Applications containerization
</h1>
<div class=post-meta>October 20, 2021
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://ggp1.github.io/images/containers.jpg alt="Applications containerization">
</figure>
<div class=post-content><p>The concept of containerization was first introduced in 1979 during the development of <a href=https://en.wikipedia.org/wiki/Chroot>chroot</a> (Version 7 Unix), which restricted an application&rsquo;s file access to a specific directory - the root - and its children.</p>
<p>The main benefit chroot brought in was <strong>process isolation</strong>, improving the system security such that an internal vulnerability wouldn&rsquo;t affect external systems.</p>
<p>In fact, chroot was the first of a series of technologies designed to protect each process from the others on the operating system.</p>
<p>More than two decades later, in 2002, a feature called <strong><a href=https://en.wikipedia.org/wiki/Linux_namespaces>namespaces</a></strong> was included into the Linux kernel.</p>
<p>Namespaces partition kernel resources such that one set of processes sees one set of resources while another set of processes sees a different set of resources.</p>
<p>Five years later, engineers at Google released <strong><a href=https://en.wikipedia.org/wiki/Cgroups>cgroups</a></strong>, another feature that was added to the Linux kernel and that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes.</p>
<p>The two last are the main features that the Docker Inc. took advantage of when creating the <a href=https://www.docker.com/products/container-runtime>Docker Engine</a> container runtime in 2013, since then, containers have gained more and more adoption in the software industry all around the world.</p>
<h2 id=containers>Containers<a hidden class=anchor aria-hidden=true href=#containers>#</a></h2>
<p>Containers encapsulate the code, libraries and configurations necessary to run an application, they offer <strong>process-level isolation</strong> and <strong>share the kernel of the host operating system</strong> with other containers.</p>
<blockquote>
<p>While running in isolated processes could prevent malicious code from one container to impact others running in the same server, if there is a vulnerability in the kernel that would affect all of them indistinctively, as opposed to virtual machines that provide <strong>hardware-level isolation</strong>.</p>
</blockquote>
<p>The fact that they do not require an operating system per container makes them <strong>lightweight, portable and inexpensive</strong>.</p>
<p>
<center>
<figure>
<img src=/images/docker_containers.jpg alt="Docker containers running in one machine">
<figcaption>
<p align=center>
Docker containers running in one machine
</p>
</figcaption>
</figure>
</center>
</p>
<p>Multiple containers can be created easily and fast in <strong>any machine running the Docker Engine</strong>.</p>
<p>Like virtual machines, they are already set up and ready for the application to run, providing a consistent solution and saving a lot of time to developers.</p>
<h2 id=application>Application<a hidden class=anchor aria-hidden=true href=#application>#</a></h2>
<p>We will use the following super simple server written in Go to demonstrate how to containerize applications efficiently:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#ff79c6>package</span> main

<span style=color:#ff79c6>import</span> (
	<span style=color:#f1fa8c>&#34;net/http&#34;</span>
	<span style=color:#f1fa8c>&#34;fmt&#34;</span>
	<span style=color:#f1fa8c>&#34;log&#34;</span>
)

<span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
	http.<span style=color:#50fa7b>HandleFunc</span>(<span style=color:#f1fa8c>&#34;/&#34;</span>, home)
	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> http.<span style=color:#50fa7b>ListenAndServe</span>(<span style=color:#f1fa8c>&#34;:3000&#34;</span>, <span style=color:#ff79c6>nil</span>); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
		log.<span style=color:#50fa7b>Fatal</span>(err)
	}
}

<span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>home</span>(w http.ResponseWriter, r <span style=color:#ff79c6>*</span>http.Request) {
	fmt.<span style=color:#50fa7b>Fprint</span>(w, <span style=color:#f1fa8c>&#34;Hello world&#34;</span>)
}
</code></pre></div><p>The docker image we are going to build is more or less similar to the ones you would use in any other compiled language so, without further ado, let&rsquo;s start.</p>
<h3 id=dockerfile>Dockerfile<a hidden class=anchor aria-hidden=true href=#dockerfile>#</a></h3>
<p>We will start off with a <strong>naive image</strong>, improving it along the way and explaning the improvements.</p>
<p>The directory we are using has the following structure</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>└── app
  ├── main.go
  ├── Dockerfile
  └── go.mod
</code></pre></div><p>and the initial Dockerfile looks like</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#6272a4># Start from an image with the Go language and its dependencies installed</span>
<span style=color:#ff79c6>FROM</span><span style=color:#f1fa8c> golang:latest</span>

<span style=color:#6272a4># Move into the &#34;/app&#34; directory (it&#39;s created if not exists)</span>
<span style=color:#ff79c6>WORKDIR</span><span style=color:#f1fa8c> /app</span>

<span style=color:#6272a4># Copy everything inside the host&#39;s current directory into the image&#39;s &#34;/app&#34; </span>
<span style=color:#6272a4># directory (&#34;.&#34; means current directory)</span>
<span style=color:#6272a4># COPY &lt;host src&gt; &lt;container dst&gt;</span>
<span style=color:#ff79c6>COPY</span> . .

<span style=color:#6272a4># Compile server and put the binary inside the image&#39;s current directory, </span>
<span style=color:#6272a4># thus it will be at &#34;/app/server&#34;</span>
<span style=color:#6272a4># go build -o &lt;path&gt;</span>
<span style=color:#ff79c6>RUN</span> go build -o server

<span style=color:#6272a4># When the image is run in a container, execute the binary</span>
<span style=color:#ff79c6>CMD</span> [<span style=color:#f1fa8c>&#34;/app/server&#34;</span>]
</code></pre></div><p>Having the image specification done we only have to move into the directory containing the file and build it executing <code>docker build -t server .</code>, here&rsquo;s the result:</p>
<p>
<center>
<figure>
<img src=/images/server_image0.jpg alt="Basic image">
<figcaption>
<p align=center>
Basic image
</p>
</figcaption>
</figure>
</center>
</p>
<p>To run the image inside a container and expose our server execute <code>docker run -p 3000:3000 server</code>.</p>
<blockquote>
<p>The -t flag takes the image&rsquo;s tag name: <code>-t &lt;name></code>.</p>
<p>The -p flag publishes a container&rsquo;s port to the host: <code>-p &lt;host port>:&lt;container port></code>.</p>
</blockquote>
<p>Perfect, our server is up and running, we&rsquo;re done! Well, not so fast, we can do it much better.</p>
<h3 id=image-versioning>Image versioning<a hidden class=anchor aria-hidden=true href=#image-versioning>#</a></h3>
<p>In our first example we didn&rsquo;t specify the version of the image we started from, if the Go team releases a new version with <strong>breaking changes</strong> our application will be built from it and <strong>potentially break</strong>.</p>
<p>To fix this, we can visit the <a href=https://hub.docker.com/_/golang>Go official images on Docker Hub</a> and find a version that suits our needs, in this case I&rsquo;m going to use the <a href=https://hub.docker.com/_/alpine>alpine</a>-based version.</p>
<blockquote>
<p>Alpine is minimal Docker image based on Alpine Linux with a complete package index and only 5 MB in size.</p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#ff79c6>FROM</span><span style=color:#f1fa8c> golang:1.17.1-alpine3.14</span>
</code></pre></div><p>With this change only, we are going to avoid broken CI/CD pipelines and save 626 MB of space.</p>
<p>
<center>
<figure>
<img src=/images/server_image1.jpg alt="1.17.1-alpine3.14 version">
<figcaption>
<p align=center>
1.17.1-alpine3.14 version
</p>
</figcaption>
</figure>
</center>
</p>
<p>The only reason not to start from an alpine image is if it does not support a package/tool that your application requires to build or run.</p>
<h3 id=modules-caching>Modules caching<a hidden class=anchor aria-hidden=true href=#modules-caching>#</a></h3>
<p>If we were to develop using Docker with the image above, every change we make in the application&rsquo;s code would leave Docker&rsquo;s caching layer useless.</p>
<p>When building the image, dependencies are downloaded when the application is compiled (<code>go build -o server</code>) but if we modify a single line of code we change the directory&rsquo;s content and invalidate Docker&rsquo;s caching layer, forcing the process to download all the dependencies again.</p>
<p>In order to fix this issue, we are going to copy and download the Go modules before any change is introduced (in other languages this may be done differently).</p>
<p>The next time the image is built, they will be taken from the cache instead of re-downloaded, unless we add or remove a dependency.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#6272a4># Copy the modules file and put it in the container</span>
<span style=color:#ff79c6>COPY</span> go.mod .

<span style=color:#6272a4># Download modules</span>
<span style=color:#ff79c6>RUN</span> go mod download

<span style=color:#6272a4># Previously, this step was invalidating the cache</span>
<span style=color:#ff79c6>COPY</span> . .

<span style=color:#6272a4># Normally it would try to download the modules here but they are now cached</span>
<span style=color:#ff79c6>RUN</span> go build -o server
</code></pre></div><h3 id=removing-binary-debug-flags>Removing binary debug flags<a hidden class=anchor aria-hidden=true href=#removing-binary-debug-flags>#</a></h3>
<blockquote>
<p>This is <strong>Go-specific</strong></p>
</blockquote>
<p>The binary size can be reduced by removing the symbol table and DWARF debugging information generation from it.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#ff79c6>RUN</span> go build -o server -ldflags<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;-s -w&#34;</span>
</code></pre></div><h2 id=multi-stage-builds>Multi-stage builds<a hidden class=anchor aria-hidden=true href=#multi-stage-builds>#</a></h2>
<p>Each instruction in the dockerfile adds a layer to the image and creates artifacts for its execution, multi-stage builds allow us to copy artifacts from one stage to another and leave behind those that won&rsquo;t take part in the final image.</p>
<blockquote>
<p>We are left with the image from the final stage only, the other ones behave like temporary tables/files.</p>
</blockquote>
<p>In other words, they allow us to <strong>segmentate the building process</strong> in order to get to a final image containing just what we need to run our application, leaving behind the dependencies used for its compilation.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#6272a4># ----- First stage -----</span>
<span style=color:#6272a4># Declare this image as builder</span>
<span style=color:#ff79c6>FROM</span><span style=color:#f1fa8c> golang:1.17.1-alpine3.14 AS builder</span>

<span style=color:#ff79c6>WORKDIR</span><span style=color:#f1fa8c> /app</span>

<span style=color:#ff79c6>COPY</span> go.mod .

<span style=color:#ff79c6>RUN</span> go mod download

<span style=color:#ff79c6>COPY</span> . .

<span style=color:#ff79c6>RUN</span> go build -o server -ldflags<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;-s -w&#34;</span>

<span style=color:#6272a4># ----- Second stage -----</span>
<span style=color:#ff79c6>FROM</span><span style=color:#f1fa8c> alpine:3.14.2</span>

<span style=color:#6272a4># Copy the binary from the builder to this image</span>
<span style=color:#ff79c6>COPY</span> --from<span style=color:#ff79c6>=</span>builder /app/server .

<span style=color:#ff79c6>CMD</span> [<span style=color:#f1fa8c>&#34;/server&#34;</span>]
</code></pre></div><p>
<center>
<figure>
<img src=/images/server_image2.jpg alt="Multi-stage builds">
<figcaption>
<p align=center>
Multi-stage builds
</p>
</figcaption>
</figure>
</center>
</p>
<p>Voilà! We have reduced the image size from 321MB to just 11.7MB. But this is not the end, let&rsquo;s see what else can be improved.</p>
<h2 id=limited-privileges>Limited privileges<a hidden class=anchor aria-hidden=true href=#limited-privileges>#</a></h2>
<p>Containers built with the images we just reviewed allow executing commands and can be accessed with root privileges by using <code>docker exec -it &lt;containerID> sh</code>.</p>
<p>This should be avoided at all cost since an attacker could get to the container and do whatever he pleases with it and its information.</p>
<p>If for some reason you need command execution, create a user with limited privileges and switch to it like so:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#ff79c6>FROM</span><span style=color:#f1fa8c> alpine:3.14.2</span>

<span style=color:#6272a4># Set USER and UID environment variables</span>
<span style=color:#ff79c6>ENV</span> <span style=color:#8be9fd;font-style:italic>USER</span><span style=color:#ff79c6>=</span>&lt;username&gt;
<span style=color:#ff79c6>ENV</span> <span style=color:#8be9fd;font-style:italic>UID</span><span style=color:#ff79c6>=</span>&lt;uid&gt;

<span style=color:#ff79c6>COPY</span> --from<span style=color:#ff79c6>=</span>builder /app/server .

<span style=color:#6272a4># Add user and change the binary file ownership and permissions</span>
<span style=color:#ff79c6>RUN</span> adduser <span style=color:#8be9fd;font-style:italic>$USER</span> -D -g <span style=color:#f1fa8c>&#34;&#34;</span> -s <span style=color:#f1fa8c>&#34;/sbin/nologin&#34;</span> -u <span style=color:#8be9fd;font-style:italic>$UID</span> <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>    <span style=color:#ff79c6>&amp;&amp;</span> chown <span style=color:#8be9fd;font-style:italic>$USER</span> /server <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>    <span style=color:#ff79c6>&amp;&amp;</span> chmod <span style=color:#bd93f9>0700</span> /server

<span style=color:#6272a4># Switch to the user created to execute the command as $USER</span>
<span style=color:#ff79c6>USER</span><span style=color:#f1fa8c> $USER</span>

<span style=color:#ff79c6>CMD</span> [<span style=color:#f1fa8c>&#34;/server&#34;</span>]
</code></pre></div><h2 id=from-scratch>FROM scratch<a hidden class=anchor aria-hidden=true href=#from-scratch>#</a></h2>
<p><em><a href=https://hub.docker.com/_/scratch/#!>scratch</a></em> is Docker&rsquo;s base image, as of version 1.5.0 is a no-op and <strong>it won&rsquo;t create an extra layer</strong> in the image.</p>
<p>Using <code>FROM scratch</code> signals to the build process that the next command in the Dockerfile is the first filesystem layer.</p>
<p>This image doesn&rsquo;t have a shell installed so it&rsquo;s not possible to enter the container and execute commands, increasing the security and reducing the size of the image.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#ff79c6>FROM</span><span style=color:#f1fa8c> golang:1.17.1-alpine3.14 AS builder</span>

<span style=color:#ff79c6>WORKDIR</span><span style=color:#f1fa8c> /app</span>

<span style=color:#ff79c6>COPY</span> go.mod .

<span style=color:#ff79c6>RUN</span> go mod download

<span style=color:#ff79c6>COPY</span> . .

<span style=color:#ff79c6>RUN</span> <span style=color:#8be9fd;font-style:italic>CGO_ENABLED</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>0</span> go build -o server -ldflags<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;-s -w&#34;</span>

<span style=color:#6272a4># --------------------</span>
<span style=color:#ff79c6>FROM</span><span style=color:#f1fa8c> scratch</span>

<span style=color:#ff79c6>COPY</span> --from<span style=color:#ff79c6>=</span>builder /app/server .

<span style=color:#ff79c6>ENTRYPOINT</span> [<span style=color:#f1fa8c>&#34;/server&#34;</span>]
</code></pre></div><blockquote>
<p>In Go, it&rsquo;s necessary to disable CGO (<code>CGO_ENABLED=0</code>) when building from scratch so the executable does not depend on the system C libraries and will embed everything it needs to run.</p>
</blockquote>
<p>
<center>
<figure>
<img src=/images/server_image3.jpg alt="From scratch">
<figcaption>
<p align=center>
FROM scratch
</p>
</figcaption>
</figure>
</center>
</p>
<p>If you are looking to serve through HTTPS you will have to add the two following lines:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#6272a4># First stage</span>
<span style=color:#ff79c6>RUN</span> apk add --update --no-cache git ca-certificates <span style=color:#ff79c6>&amp;&amp;</span> update-ca-certificates

<span style=color:#6272a4># Second stage</span>
<span style=color:#ff79c6>COPY</span> --from<span style=color:#ff79c6>=</span>builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
</code></pre></div><h2 id=wrapping-up>Wrapping up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2>
<p>In summary, we have covered how to take advantage of image versioning, modules caching, limited privileges and multi-stage builds to deliver reliable, small and secure images.</p>
<p>From now on, we can run our server in any machine with Docker installed, use Kubernetes to orchestrate different copies of it and/or use a cloud provider to let the world consume our services in just a few minutes.</p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=next href=https://ggp1.github.io/posts/protect_your_information/>
<span class=title>Next Page »</span>
<br>
<span>Protect your information</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 &#183; Gastón Palomeque</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>