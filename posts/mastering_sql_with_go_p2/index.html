<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta http-equiv=Accept-CH content="DPR, Viewport-Width, Width"><link rel=icon href=/favicon.ico type=image/gif><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" media=print onload='this.media="all"'><noscript><link href="https://fonts.googleapis.com/css2?family=Alata&family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel=stylesheet></noscript><link rel=stylesheet href=/css/font.css media=all><meta property="og:url" content="https://gastonpalomeque.com/posts/mastering_sql_with_go_p2/"><meta property="og:site_name" content="Gastón Palomeque"><meta property="og:title" content="Mastering SQL with Go - Part 2"><meta property="og:description" content="This is the part 2 of a series covering sql and Go, this time, we will cover how to work with SQL transactions context and isolation levels, results dynamic scanning, full text search and recursive queries as well as using multiple result sets to do many queries in a single roundtrip.
To go to part one, click here.
Transactions Let’s start with transactions, why are they necessary?
A transaction is a way for an application to group several reads and writes together into a logical unit."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-13T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-13T00:00:00+00:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="SQL"><meta name=twitter:card content="summary"><meta name=twitter:title content="Mastering SQL with Go - Part 2"><meta name=twitter:description content="This is the part 2 of a series covering sql and Go, this time, we will cover how to work with SQL transactions context and isolation levels, results dynamic scanning, full text search and recursive queries as well as using multiple result sets to do many queries in a single roundtrip.
To go to part one, click here.
Transactions Let’s start with transactions, why are they necessary?
A transaction is a way for an application to group several reads and writes together into a logical unit."><link rel=stylesheet href=/bootstrap-5/css/bootstrap.min.css media=all><link rel=stylesheet href=/css/header.css media=all><link rel=stylesheet href=/css/footer.css media=all><link rel=stylesheet href=/css/theme.css media=all><style>:root{--text-color:#000;--text-secondary-color:#6c757d;--text-link-color:#4d7fb5;--background-color:#eaedf0;--secondary-background-color:#64ffda1a;--primary-color:#4d7fb5;--secondary-color:#f8f9fa;--text-color-dark:#e4e6eb;--text-secondary-color-dark:#b0b3b8;--text-link-color-dark:#ffffff;--background-color-dark:#18191a;--secondary-background-color-dark:#212529;--primary-color-dark:#ffffff;--secondary-color-dark:#212529}body{font-size:1rem;font-weight:400;line-height:1.5;text-align:left}html{background-color:var(--background-color)!important}body::-webkit-scrollbar{height:0;width:8px;background-color:var(--background-color)}::-webkit-scrollbar-track{border-radius:1rem}::-webkit-scrollbar-thumb{border-radius:1rem;background:#b0b0b0;outline:1px solid var(--background-color)}#search-content::-webkit-scrollbar{width:.5em;height:.1em;background-color:var(--background-color)}</style><meta name=description content><link rel=stylesheet href=/css/single.css><script defer src=/fontawesome-6/all-6.4.2.js></script><title>Mastering SQL with Go - Part 2 | Gastón Palomeque</title></head><body class=light><script>let localStorageValue=localStorage.getItem("pref-theme"),mediaQuery=window.matchMedia("(prefers-color-scheme: dark)").matches;switch(localStorageValue){case"dark":document.body.classList.add("dark");break;case"light":document.body.classList.remove("dark");break;default:mediaQuery&&document.body.classList.add("dark");break}</script><script>var prevScrollPos=window.pageYOffset;window.addEventListener("scroll",function(){let s=document.getElementById("profileHeader"),t=window.pageYOffset,n=!1,o=!0,i=o?prevScrollPos>t:t>0;i?s.classList.add("showHeaderOnTop"):n=!0,t===0&&(n=!0),n&&s.classList.remove("showHeaderOnTop"),prevScrollPos=t})</script><header id=profileHeader><nav class="pt-3 navbar navbar-expand-lg animate"><div class="container-fluid mx-xs-2 mx-sm-5 mx-md-5 mx-lg-5"><a class="navbar-brand primary-font text-wrap" href=/><img src=/favicon.ico width=30 height=30 class="d-inline-block align-top"></a><div><input id=search autocomplete=off class="form-control mr-sm-2 d-none d-md-block" placeholder=Search aria-label=Search oninput=searchOnChange(event)></div><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarContent aria-controls=navbarContent aria-expanded=false aria-label="Toggle navigation">
<svg aria-hidden="true" height="24" viewBox="0 0 16 16" width="24" data-view-component="true"><path fill-rule="evenodd" d="M1 2.75A.75.75.0 011.75 2h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 2.75zm0 5A.75.75.0 011.75 7h12.5a.75.75.0 110 1.5H1.75A.75.75.0 011 7.75zM1.75 12a.75.75.0 100 1.5h12.5a.75.75.0 100-1.5H1.75z"/></svg></button><div class="collapse navbar-collapse text-wrap primary-font" id=navbarContent><ul class="navbar-nav ms-auto text-center"><li class="nav-item navbar-text d-block d-md-none"><div class=nav-link><input id=search autocomplete=off class="form-control mr-sm-2" placeholder=Search aria-label=Search oninput=searchOnChange(event)></div></li><li class="nav-item navbar-text"><a class=nav-link href=/#about aria-label=about>About</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#experience aria-label=experience>Experience</a></li><li class="nav-item navbar-text"><a class=nav-link href=/#projects aria-label=projects>Projects</a></li><li class="nav-item navbar-text"><a class=nav-link href=/posts/ title>Posts</a></li><li class="nav-item navbar-text"><div class=text-center><button id=theme-toggle>
<svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></li></ul></div></div></nav></header><div id=content><section id=single><div class=container><div class="row justify-content-center"><div class="col-sm-12 col-md-12 col-lg-9"><div class=pr-lg-4><div class="title mb-5"><h1 class="text-center mb-4">Mastering SQL with Go - Part 2</h1><div class=text-center>Apr 13, 2025</div></div><div class=featured-image><img class="img-fluid mx-auto d-block" src=/images/sql_go_p2.png alt="Mastering SQL with Go - Part 2"></div><article class="page-content p-2"><p>This is the part 2 of a series covering <strong>sql</strong> and <strong>Go</strong>, this time, we will cover how to work with SQL transactions context and isolation levels, results dynamic scanning, full text search and recursive queries as well as using multiple result sets to do many queries in a single roundtrip.</p><blockquote><p>To go to part one, click <a href=../mastering_sql_with_go_p1>here</a>.</p></blockquote><h2 id=transactions>Transactions</h2><p>Let&rsquo;s start with transactions, why are they necessary?</p><p>A transaction is a way for an application to group several reads and writes together into a logical unit.</p><p>Conceptually, all the reads and writes in a transaction are executed as one operation: either the entire transaction succeeds (<em>commit</em>) or it fails (<em>abort</em>/<em>rollback</em>).</p><p>They are an abstraction layer that allows an application to pretend that certain concurrency problems and certain kinds of hardware and software faults don&rsquo;t exist.</p><p>Let&rsquo;s see how can we take advantage of them.</p><h3 id=propagation-using-context>Propagation using context</h3><p>Specially in large projects, a single request can perform several calls to one or perhaps many services.</p><p>If we were to execute and commit this operations separately, any error that occurs between them leaves the database in a corrupted state.</p><p>In order to avoid this, we need to &ldquo;share&rdquo; or execute the whole workflow in a single transaction, taking advantage of the <a href=https://en.wikipedia.org/wiki/ACID>ACID</a> (atomicity, consistency, isolation, durability) properties they bring us.</p><p>This way, we commit all the changes that were made in a single and atomic transaction, making sure that they either <strong>succeed</strong> or <strong>fail completely</strong>. In some cases, if the transaction fails, we can simply retry.</p><p>Now, passing down transactions as parameters will mess the code up and it isn&rsquo;t a scalable solution. We will store the transaction in the request&rsquo;s context so it can be accessed on lower layers:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// --- sqltx.go ---</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>package</span> <span style=color:#e06c75>sqltx</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;context&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;database/sql&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// txKey is the context key for the sql transaction.</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>var</span> <span style=color:#e06c75>txKey</span> <span style=color:#e06c75>key</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>key</span> <span style=color:#c678dd>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// NewContext returns a new context with a sql transaction in it.</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>NewContext</span>(<span style=color:#e06c75>ctx</span> <span style=color:#e06c75>context</span>.<span style=color:#e06c75>Context</span>, <span style=color:#e06c75>tx</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>sql</span>.<span style=color:#e06c75>Tx</span>) <span style=color:#e06c75>context</span>.<span style=color:#e06c75>Context</span> {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>ctx</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>ctx</span> = <span style=color:#e06c75>context</span>.<span style=color:#61afef;font-weight:700>Background</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#e06c75>context</span>.<span style=color:#61afef;font-weight:700>WithValue</span>(<span style=color:#e06c75>ctx</span>, <span style=color:#e06c75>txKey</span>, <span style=color:#e06c75>tx</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// FromContext returns the sql transaction stored in the context.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//
</span></span></span><span style=display:flex><span><span style=color:#7f848e>// It panics if there is no transaction.</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>FromContext</span>(<span style=color:#e06c75>ctx</span> <span style=color:#e06c75>context</span>.<span style=color:#e06c75>Context</span>) <span style=color:#56b6c2>*</span><span style=color:#e06c75>sql</span>.<span style=color:#e06c75>Tx</span> {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>tx</span>, <span style=color:#e06c75>ok</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>ctx</span>.<span style=color:#61afef;font-weight:700>Value</span>(<span style=color:#e06c75>txKey</span>).(<span style=color:#56b6c2>*</span><span style=color:#e06c75>sql</span>.<span style=color:#e06c75>Tx</span>)
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> !<span style=color:#e06c75>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#e5c07b>panic</span>(<span style=color:#98c379>&#34;sql tx not found&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#e06c75>tx</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// --- service.go ---</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>service</span> <span style=color:#c678dd>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> (<span style=color:#e06c75>s</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>service</span>) <span style=color:#61afef;font-weight:700>MutationA</span>(<span style=color:#e06c75>ctx</span> <span style=color:#e06c75>context</span>.<span style=color:#e06c75>Context</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>sqlTx</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>sqltx</span>.<span style=color:#61afef;font-weight:700>FromContext</span>(<span style=color:#e06c75>ctx</span>)
</span></span><span style=display:flex><span>	<span style=color:#e06c75>q</span> <span style=color:#56b6c2>:=</span> <span style=color:#98c379>&#34;INSERT INTO posts (id, title, content) VALUES (&#39;1&#39;, &#39;Title&#39;, &#39;Post content&#39;)&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>sqlTx</span>.<span style=color:#61afef;font-weight:700>ExecContext</span>(<span style=color:#e06c75>ctx</span>, <span style=color:#e06c75>q</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> (<span style=color:#e06c75>s</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>service</span>) <span style=color:#61afef;font-weight:700>MutationB</span>(<span style=color:#e06c75>ctx</span> <span style=color:#e06c75>context</span>.<span style=color:#e06c75>Context</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>sqlTx</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>sqltx</span>.<span style=color:#61afef;font-weight:700>FromContext</span>(<span style=color:#e06c75>ctx</span>)
</span></span><span style=display:flex><span>	<span style=color:#e06c75>sqlTx</span>.<span style=color:#61afef;font-weight:700>ExecContext</span>(<span style=color:#e06c75>ctx</span>, <span style=color:#98c379>&#34;UPDATE users SET posts_count = posts_count + 1&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// --- handler.go ---</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// db and service objects creation omitted to simplify the scenario</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>HandleRequest</span>(<span style=color:#e06c75>w</span> <span style=color:#e06c75>http</span>.<span style=color:#e06c75>ResponseWriter</span>, <span style=color:#e06c75>r</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>http</span>.<span style=color:#e06c75>Request</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>tx</span>, <span style=color:#e06c75>_</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>db</span>.<span style=color:#61afef;font-weight:700>BeginTx</span>()
</span></span><span style=display:flex><span>	<span style=color:#c678dd>defer</span> <span style=color:#e06c75>tx</span>.<span style=color:#61afef;font-weight:700>Rollback</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>ctx</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>sqltx</span>.<span style=color:#61afef;font-weight:700>NewContext</span>(<span style=color:#e06c75>r</span>.<span style=color:#61afef;font-weight:700>Context</span>(), <span style=color:#e06c75>tx</span>)
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>err</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>service</span>.<span style=color:#61afef;font-weight:700>MutationA</span>(<span style=color:#e06c75>ctx</span>); <span style=color:#e06c75>err</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#7f848e>// Rollback changes</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>err</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>service</span>.<span style=color:#61afef;font-weight:700>MutationB</span>(<span style=color:#e06c75>ctx</span>); <span style=color:#e06c75>err</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#7f848e>// Rollback changes</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// Commit both mutations atomically, in case of a failure none will take effect</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>_</span> = <span style=color:#e06c75>tx</span>.<span style=color:#61afef;font-weight:700>Commit</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This way, we can easily use the same transaction in different operations and even services. Given that it&rsquo;s stored at the request-level, the action the user took will either succeed or fail, but it will always prevent leaving the system in a corrupted state.</p><p>But this is not the only thing to take into account when working with SQL, there is also different kind of transactions that have different consistency and performance trade-offs, let&rsquo;s review them.</p><h3 id=isolation-levels>Isolation levels</h3><p>Many databases support setting different isolation levels to transactions, an isolation level determines the degree to which that data is isolated from other concurrent processes.</p><p>A lower isolation level allows many users to access the same information at the same time, but increases the probabilities of encountering inconsistencies among the different results. A higher isolation level ensures less concurrency effects but requires most system resources and the chances that one transaction may block another.</p><p>Some of the ones supported by the Go standard library package are:</p><ul><li><p><strong>Read uncommitted</strong>: In this level a transaction may see uncommited changes made by other transactions, it&rsquo;s the lowest isolation level.</p><blockquote><p>PostgreSQL&rsquo;s Read Uncommitted mode behaves like Read Committed.</p></blockquote></li><li><p><strong>Read committed</strong>: It&rsquo;s the default level. A query sees only data committed before the query began; it never sees either uncommitted data or changes committed during query execution by concurrent transactions.</p><p>However, the query does see the effects of previous updates executed within its own transaction, even though they are not yet committed.</p><p>Note that two successive <code>SELECT</code> commands can see different data.</p></li><li><p><strong>Repeatable read</strong>: In this level, the transaction only sees data committed before it began.</p><p>This level is different from Read Committed in that a query in a repeatable read transaction sees a snapshot as of the start of the first non-transaction-control statement in the transaction, not as of the start of the current statement within the transaction. Thus, successive SELECT commands within a single transaction see the same data.</p></li><li><p><strong>Serializable</strong>: It is the strictest isolation level. In it, transactions are executed sequentially, that is, one after another and without any concurrency.</p></li></ul><p>In Go, one could create a transaction with a specific isolation level by doing:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#e06c75>tx</span>, <span style=color:#e06c75>err</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>db</span>.<span style=color:#61afef;font-weight:700>BeginTx</span>(<span style=color:#e06c75>ctx</span>, <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>sql</span>.<span style=color:#e06c75>TxOptions</span>{<span style=color:#e06c75>Isolation</span>: <span style=color:#e06c75>sql</span>.<span style=color:#e06c75>LevelSerializable</span>})
</span></span></code></pre></div><p>Having discussed how to manage transactions and the different kind of them, let&rsquo;s move over to the concept of dynamic scanning, parsing SQL transactions results without having to code one method per query.</p><h2 id=dynamic-scanning>Dynamic scanning</h2><p>The Go standard library provides a basic interface that does an acceptable job, but in some cases it falls behind requirements like:</p><ul><li>Use always the same method for scanning any type of object</li><li>Scan fields dynamically (let the user choose which fields to receive)</li><li>Simple and compact interface</li></ul><p>Let&rsquo;s take a look at how we would scan fields into an object with Go&rsquo;s native methods</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>Post</span> <span style=color:#c678dd>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>Title</span> <span style=color:#e5c07b>string</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>Content</span> <span style=color:#e5c07b>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>getPosts</span>(<span style=color:#e06c75>id</span> <span style=color:#e5c07b>string</span>) ([]<span style=color:#e06c75>Post</span>, <span style=color:#e5c07b>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>rows</span>, <span style=color:#e06c75>_</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>db</span>.<span style=color:#61afef;font-weight:700>Query</span>(<span style=color:#98c379>&#34;SELECT title, content FROM posts WHERE id=$1&#34;</span>, <span style=color:#e06c75>id</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>var</span> <span style=color:#e06c75>posts</span> []<span style=color:#e06c75>Post</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>rows</span>.<span style=color:#61afef;font-weight:700>Next</span>() {
</span></span><span style=display:flex><span>		<span style=color:#c678dd>var</span> <span style=color:#e06c75>post</span> <span style=color:#e06c75>Post</span>
</span></span><span style=display:flex><span>		<span style=color:#7f848e>// Here we would have to add all the fields we want to scan, </span>
</span></span><span style=display:flex><span>		<span style=color:#7f848e>// the bigger the struct and the query the messier it becomes</span>
</span></span><span style=display:flex><span>		<span style=color:#c678dd>if</span> <span style=color:#e06c75>err</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>rows</span>.<span style=color:#61afef;font-weight:700>Scan</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>post</span>.<span style=color:#e06c75>Title</span>, <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>post</span>.<span style=color:#e06c75>Content</span>); <span style=color:#e06c75>err</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#c678dd>return</span> <span style=color:#e5c07b>nil</span>, <span style=color:#e06c75>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#e06c75>posts</span> = <span style=color:#e5c07b>append</span>(<span style=color:#e06c75>posts</span>, <span style=color:#e06c75>post</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>err</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>rows</span>.<span style=color:#61afef;font-weight:700>Close</span>(); <span style=color:#e06c75>err</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#c678dd>return</span> <span style=color:#e06c75>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#e06c75>posts</span>, <span style=color:#e5c07b>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This implementation is verbose, it would require us to create a method for every query (or at least those that are not equal) and the fields returned are hardcoded.</p><p>Hopefully, we have many solutions for these problems, there are many production-ready packages that help manage sql queries in a simple and clean way.</p><p>In this case, I&rsquo;m going to introduce one that is simple, compatible with the standard library and that supports recursive mapping of object fields. It&rsquo;s called <a href=https://github.com/GGP1/sqan>sqan</a>, and I will explain how it works in the next two sections: <em>mapping</em> and <em>scanning</em>.</p><h3 id=mapping>Mapping</h3><p>Sqan maps objects fields using a nested map where the top level key is the field type, the inner map then uses the field names or their <code>db</code> tag (if specified) as the key and the indices they represent inside the struct as the value.</p><blockquote><p>Unexported fields and struct slices are skipped</p></blockquote><p>For example, the following struct</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>Post</span> <span style=color:#c678dd>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>Title</span> <span style=color:#e5c07b>string</span> <span style=color:#98c379>`db:&#34;title&#34;`</span> <span style=color:#7f848e>// Optional, could be any string</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>Content</span> <span style=color:#e5c07b>string</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>Comment</span> <span style=color:#e06c75>Comment</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>Comment</span> <span style=color:#c678dd>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>Content</span> <span style=color:#e5c07b>string</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>Likes</span> <span style=color:#e5c07b>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>is mapped like</p><pre tabindex=0><code>Post:
	title: 0
	content: 1
	content: 2 0
	likes: 2 1
</code></pre><p>The field&rsquo;s type and indices are obtained using reflection, in case the field is an embedded struct, the mapping is done in the same way as the top one (using recursion).</p><p>The mapping is executed the first time the struct is used to store sql results and the information remains in memory and ready to be used by the scanner.</p><h3 id=scanning>Scanning</h3><p>When scanning results, Sqan looks for the columns names in the SQL query and creates a slice with the fields required and an empty value for each of them, which will then be populated by the SQL scanner with the values retrieved from the database.</p><p>It uses the field&rsquo;s indices stored in the map to know where to allocate the empty value and reflection to create it.</p><p>And that&rsquo;s how we use every value from the map to generate dynamic slices to scan SQL results.</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>getPosts</span>(<span style=color:#e06c75>id</span> <span style=color:#e5c07b>string</span>) ([]<span style=color:#e06c75>Post</span>, <span style=color:#e5c07b>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>rows</span>, <span style=color:#e06c75>_</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>db</span>.<span style=color:#61afef;font-weight:700>Query</span>(<span style=color:#98c379>&#34;SELECT title, content FROM posts WHERE id=$1&#34;</span>, <span style=color:#e06c75>id</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>var</span> <span style=color:#e06c75>posts</span> []<span style=color:#e06c75>Post</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>err</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>sqan</span>.<span style=color:#61afef;font-weight:700>Rows</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>posts</span>, <span style=color:#e06c75>rows</span>); <span style=color:#e06c75>err</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#c678dd>return</span> <span style=color:#e5c07b>nil</span>, <span style=color:#e06c75>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#e06c75>posts</span>, <span style=color:#e5c07b>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now our Go code is not only simpler, but we could also let the clients (validating and sanitizing their inputs) ask for fields on demand.</p><blockquote><p>Sqan also works when scanning a single value (<code>sqan.Row()</code>)</p></blockquote><h2 id=full-text-search>Full Text Search</h2><p>There are cases in which a simple <code>SELECT &lt;fields></code> falls short to deliver what we are looking for. Full text search is one of those cases, if we want to get rows that contain but are not equals to a speficic value, we will have to use them. Let&rsquo;s see how they work.</p><p>To implement full text searching there must be a function to create a <code>tsvector</code> from a document and a <code>tsquery</code> from a user query.</p><p>The function we are going to use is<code>to_tsvector</code>, which parses a textual document into tokens and reduces the tokens to lexemes. Here is an example:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#c678dd>SELECT</span> <span style=color:#e06c75>to_tsvector</span>(<span style=color:#98c379>&#39;english&#39;</span>, <span style=color:#98c379>&#39;a fat  cat sat on a mat - it ate a fat rats&#39;</span>);
</span></span><span style=display:flex><span>                  <span style=color:#e06c75>to_tsvector</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>-----------------------------------------------------
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span> <span style=color:#98c379>&#39;ate&#39;</span>:<span style=color:#d19a66>9</span> <span style=color:#98c379>&#39;cat&#39;</span>:<span style=color:#d19a66>3</span> <span style=color:#98c379>&#39;fat&#39;</span>:<span style=color:#d19a66>2</span>,<span style=color:#d19a66>11</span> <span style=color:#98c379>&#39;mat&#39;</span>:<span style=color:#d19a66>7</span> <span style=color:#98c379>&#39;rat&#39;</span>:<span style=color:#d19a66>12</span> <span style=color:#98c379>&#39;sat&#39;</span>:<span style=color:#d19a66>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>-- The resulting tsvector does not contain the words a, on, or it, the word rats became rat, and the punctuation sign - was ignored
</span></span></span></code></pre></div><p>We can use the function <code>to_tsvector()</code> to create a vector on a table field. For example, here we will look for the text &ldquo;Rice&rdquo; in the field &ldquo;title&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// If you want to match any string starting with the value below, add &#34;:*&#34; to it to match prefixes as well</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>text</span> <span style=color:#56b6c2>:=</span> <span style=color:#98c379>&#34;Rice&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>q</span> <span style=color:#56b6c2>:=</span> <span style=color:#98c379>&#34;SELECT title, description FROM posts WHERE to_tsvector(title) @@ plainto_tsquery($1)&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>db</span>.<span style=color:#61afef;font-weight:700>Query</span>(<span style=color:#e06c75>q</span>, <span style=color:#e06c75>text</span>)
</span></span></code></pre></div><blockquote><p><code>plainto_tsquery</code> transforms the unformatted text querytext to a <code>tsquery</code> value. The text is parsed and normalized much as for to_tsvector, then the & (AND) tsquery operator is inserted between surviving words.</p></blockquote><p>It will return all the products that contain the word &ldquo;Rice&rdquo; on its title.</p><p>To look for text on several fields, concatenate using <code>|| ' ' ||</code>:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#98c379>&#34;... to_tsvector(title || &#39; &#39; || description) ...&#34;</span>
</span></span></code></pre></div><blockquote><p>There&rsquo;s no limit to the number of fields that can be included as vectors to look for text in them, the only constraint is performance.</p></blockquote><p>However, by querying information this way, we are creating the vectors on the fly and if we perform many queries of these type the SQL engine would have to generate the indices on each one of the operations, which is really inefficient.</p><p>To solve this, we can instruct the database to create the index when the table is created and to update it each time a new row is inserted, effectively moving the calculations to the <em>write side</em>.</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#c678dd>CREATE</span> <span style=color:#c678dd>TABLE</span> <span style=color:#c678dd>IF</span> <span style=color:#c678dd>NOT</span> <span style=color:#c678dd>EXISTS</span> <span style=color:#e06c75>products</span>
</span></span><span style=display:flex><span>(
</span></span><span style=display:flex><span>	<span style=color:#e06c75>title</span> <span style=color:#e5c07b>text</span> <span style=color:#c678dd>NOT</span> <span style=color:#c678dd>NULL</span>,
</span></span><span style=display:flex><span>	<span style=color:#e06c75>description</span> <span style=color:#e5c07b>text</span> <span style=color:#c678dd>NOT</span> <span style=color:#c678dd>NULL</span>,
</span></span><span style=display:flex><span>	<span style=color:#c678dd>search</span> <span style=color:#e06c75>tsvector</span> <span style=color:#7f848e>-- The search field will represent an index of both title and description field contents
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>-- Create index of type GIN (more about GIN at https://www.postgresql.org/docs/15/gin-intro.html)
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#c678dd>CREATE</span> <span style=color:#c678dd>INDEX</span> <span style=color:#c678dd>ON</span> <span style=color:#e06c75>products</span> <span style=color:#c678dd>USING</span> <span style=color:#e06c75>GIN</span> (<span style=color:#c678dd>search</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>-- Create the function that creates the index
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#c678dd>CREATE</span> <span style=color:#c678dd>OR</span> <span style=color:#c678dd>REPLACE</span> <span style=color:#c678dd>FUNCTION</span> <span style=color:#e06c75>products_tsvector_trigger</span>() <span style=color:#c678dd>RETURNS</span> <span style=color:#c678dd>trigger</span> <span style=color:#c678dd>AS</span> $$
</span></span><span style=display:flex><span><span style=color:#c678dd>BEGIN</span>
</span></span><span style=display:flex><span>	<span style=color:#7f848e>-- setweight takes a vector and a letter, and it&#39;s typically used to mark different parts of a document
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>	<span style=color:#7f848e>-- Later, they can be used for ranking search results
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>	<span style=color:#c678dd>new</span>.<span style=color:#c678dd>search</span> :<span style=color:#56b6c2>=</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>setweight</span>(<span style=color:#e06c75>to_tsvector</span>(<span style=color:#98c379>&#39;english&#39;</span>, <span style=color:#c678dd>new</span>.<span style=color:#e06c75>title</span>), <span style=color:#98c379>&#39;A&#39;</span>)
</span></span><span style=display:flex><span>	<span style=color:#56b6c2>||</span> <span style=color:#e06c75>setweight</span>(<span style=color:#e06c75>to_tsvector</span>(<span style=color:#98c379>&#39;english&#39;</span>, <span style=color:#c678dd>new</span>.<span style=color:#e06c75>description</span>), <span style=color:#98c379>&#39;B&#39;</span>);
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#c678dd>new</span>;
</span></span><span style=display:flex><span><span style=color:#c678dd>END</span>
</span></span><span style=display:flex><span>$$ <span style=color:#c678dd>LANGUAGE</span> <span style=color:#e06c75>plpgsql</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>-- Delete the trigger if it existed previously so the operation below does not fail
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#c678dd>DROP</span> <span style=color:#c678dd>TRIGGER</span> <span style=color:#c678dd>IF</span> <span style=color:#c678dd>EXISTS</span> <span style=color:#e06c75>products_tsvector_update</span> <span style=color:#c678dd>ON</span> <span style=color:#e06c75>products</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>-- Instruct the database to execute the trigger before each product addition
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span><span style=color:#c678dd>CREATE</span> <span style=color:#c678dd>TRIGGER</span> <span style=color:#e06c75>products_tsvector_update</span> <span style=color:#c678dd>BEFORE</span> <span style=color:#c678dd>INSERT</span> <span style=color:#c678dd>OR</span> <span style=color:#c678dd>UPDATE</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>ON</span> <span style=color:#e06c75>products</span> <span style=color:#c678dd>FOR</span> <span style=color:#c678dd>EACH</span> <span style=color:#c678dd>ROW</span> <span style=color:#c678dd>EXECUTE</span> <span style=color:#c678dd>PROCEDURE</span> <span style=color:#e06c75>products_tsvector_trigger</span>();
</span></span></code></pre></div><blockquote><p>If the fields you are using can be null, you should use the <code>coalesce()</code> function when creating the index to convert the content to an empty string, i.e <code>to_tsvector(coalesce(title,''))</code>. Otherwise <code>to_tsvector(NULL)</code> will return <code>NULL</code>.</p></blockquote><p>We can now look for products containing the word &ldquo;Apple&rdquo; in their <code>title</code> and <code>description</code> fields by using the already generated index on the <code>search</code> field:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#e06c75>db</span>.<span style=color:#61afef;font-weight:700>Query</span>(<span style=color:#98c379>&#34;SELECT title, description FROM posts WHERE search @@ plainto_tsquery(&#39;Apple&#39;)&#34;</span>)
</span></span></code></pre></div><p>Moreover, we can set the order of the query to prioritize the fields with more weight:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#e06c75>text</span> <span style=color:#56b6c2>:=</span> <span style=color:#98c379>&#34;Apple&#34;</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>db</span>.<span style=color:#61afef;font-weight:700>Query</span>(<span style=color:#98c379>`SELECT title, description 
</span></span></span><span style=display:flex><span><span style=color:#98c379>FROM posts 
</span></span></span><span style=display:flex><span><span style=color:#98c379>WHERE search @@ plainto_tsquery($1)
</span></span></span><span style=display:flex><span><span style=color:#98c379>ORDER BY ts_rank(search, plainto_tsquery($1)) DESC`</span>, <span style=color:#e06c75>text</span>)
</span></span></code></pre></div><p>As we set a higher priority to the <code>title</code> field, the ones containing the <code>Apple</code> text in it will be at the top of the list and above the products that have it in the <code>description</code> field.</p><h2 id=recursive-queries>Recursive queries</h2><p>Now imagine we want to retrieve all the replies from a post and the replies to those comments as well, this scenario is proposed for <strong>educational purposes</strong>, ideally you will need to load one comment at a time when a user requests it. The query would be as follows:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#c678dd>WITH</span> <span style=color:#c678dd>RECURSIVE</span> <span style=color:#e06c75>replies</span> <span style=color:#c678dd>AS</span> (
</span></span><span style=display:flex><span>	<span style=color:#c678dd>SELECT</span> 
</span></span><span style=display:flex><span>		<span style=color:#e06c75>id</span>, <span style=color:#e06c75>user_id</span>, <span style=color:#e06c75>content</span>
</span></span><span style=display:flex><span>		<span style=color:#c678dd>FROM</span> <span style=color:#e06c75>comments</span> <span style=color:#c678dd>WHERE</span> <span style=color:#e06c75>parent_comment_id</span><span style=color:#56b6c2>=</span>$<span style=color:#d19a66>1</span>
</span></span><span style=display:flex><span>		<span style=color:#7f848e>-- Below we get the replies of the replies and we &#34;append&#34; them
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>		<span style=color:#7f848e>-- to our current matches (the top level ones)
</span></span></span><span style=display:flex><span><span style=color:#7f848e></span>		<span style=color:#c678dd>UNION</span>
</span></span><span style=display:flex><span>			<span style=color:#c678dd>SELECT</span>
</span></span><span style=display:flex><span>			<span style=color:#c678dd>c</span>.<span style=color:#e06c75>id</span>, <span style=color:#c678dd>c</span>.<span style=color:#e06c75>parent_comment_id</span> <span style=color:#c678dd>c</span>.<span style=color:#e06c75>user_id</span>, <span style=color:#c678dd>c</span>.<span style=color:#e06c75>content</span>, 
</span></span><span style=display:flex><span>			<span style=color:#c678dd>FROM</span> <span style=color:#e06c75>comments</span> <span style=color:#c678dd>c</span>
</span></span><span style=display:flex><span>			<span style=color:#c678dd>INNER</span> <span style=color:#c678dd>JOIN</span> <span style=color:#e06c75>replies</span> <span style=color:#e06c75>r</span> <span style=color:#c678dd>ON</span> <span style=color:#e06c75>r</span>.<span style=color:#e06c75>id</span> <span style=color:#56b6c2>=</span> <span style=color:#c678dd>c</span>.<span style=color:#e06c75>parent_comment_id</span>
</span></span><span style=display:flex><span>) <span style=color:#c678dd>SELECT</span> <span style=color:#e06c75>id</span>, <span style=color:#e06c75>parent_comment_id</span>, <span style=color:#e06c75>user_id</span>, <span style=color:#e06c75>content</span> <span style=color:#c678dd>FROM</span> <span style=color:#e06c75>replies</span>
</span></span></code></pre></div><blockquote><p>If a comment is a reply to the post and not to a comment then <code>parent_comment_id</code> will be null.</p></blockquote><h2 id=multiple-result-sets>Multiple result sets</h2><p>Lastly, we will cover how to execute multiple <code>SELECT</code> queries in a single roundtrip with <em>results sets</em>.</p><p>This is really useful in cases where the database is the system&rsquo;s bottleneck because it is receiving a lot of concurrent connections. Doing all the operations in a single call can hurt a program&rsquo;s readability, but it can also reduce the network latency and optimize the overall workflow.</p><p>As you can see below, the implementation is pretty straightforward and self-explanatory.</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>getPostsAndComments</span>() <span style=color:#e5c07b>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>rows</span>, <span style=color:#e06c75>err</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>db</span>.<span style=color:#61afef;font-weight:700>Query</span>(<span style=color:#98c379>&#34;SELECT * from posts; SELECT * from comments;&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>err</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>log</span>.<span style=color:#61afef;font-weight:700>Fatal</span>(<span style=color:#e06c75>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#c678dd>defer</span> <span style=color:#e06c75>rows</span>.<span style=color:#61afef;font-weight:700>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// Loop through the posts (first query)</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>rows</span>.<span style=color:#61afef;font-weight:700>Next</span>() {
</span></span><span style=display:flex><span>		<span style=color:#7f848e>// Scan posts</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// Advance to next result set</span>
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// It returns a boolean indicating if there are further sets</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>nextSet</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>rows</span>.<span style=color:#61afef;font-weight:700>NextResultSet</span>()
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> !<span style=color:#e06c75>nextSet</span> {
</span></span><span style=display:flex><span>		<span style=color:#c678dd>return</span> <span style=color:#e06c75>rows</span>.<span style=color:#61afef;font-weight:700>Err</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// Loop through the comments (second query)</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>rows</span>.<span style=color:#61afef;font-weight:700>Next</span>() {
</span></span><span style=display:flex><span>		<span style=color:#7f848e>// Scan comments</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// Check for any error in either result set</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#e06c75>rows</span>.<span style=color:#61afef;font-weight:700>Err</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=references>References</h2><ul><li><a href=https://dataintensive.net/>Designing Data-Intensive Applications by Martin Kleppmann</a></li><li><a href=https://www.postgresql.org/docs/current/textsearch-controls.html>Controlling Text Search</a></li></ul></article></div></div><div class="col-sm-12 col-md-12 col-lg-3"><div id=stickySideBar class=sticky-sidebar><aside class=toc><h5>Table Of Contents</h5><div class=toc-content><nav id=TableOfContents><ul><li><a href=#transactions>Transactions</a><ul><li><a href=#propagation-using-context>Propagation using context</a></li><li><a href=#isolation-levels>Isolation levels</a></li></ul></li><li><a href=#dynamic-scanning>Dynamic scanning</a><ul><li><a href=#mapping>Mapping</a></li><li><a href=#scanning>Scanning</a></li></ul></li><li><a href=#full-text-search>Full Text Search</a></li><li><a href=#recursive-queries>Recursive queries</a></li><li><a href=#multiple-result-sets>Multiple result sets</a></li><li><a href=#references>References</a></li></ul></nav></div></aside><aside class=tags><h5>Tags</h5><ul class="tags-ul list-unstyled list-inline"><li class=list-inline-item><a href=https://gastonpalomeque.com/tags/go>Go</a></li><li class=list-inline-item><a href=https://gastonpalomeque.com/tags/sql>SQL</a></li></ul></aside></div></div></div><div class=row><div class="col-sm-12 col-md-12 col-lg-9 p-4"></div></div></div><button class="p-2 px-3" onclick=topFunction() id=topScroll>
<i class="fas fa-angle-up"></i></button></section><script>var topScroll=document.getElementById("topScroll");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>20||document.documentElement.scrollTop>20?topScroll.style.display="block":topScroll.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}let stickySideBarElem=document.getElementById("stickySideBar"),stickyNavBar=!0;if(stickyNavBar){let e=document.getElementById("profileHeader"),t=e.offsetHeight+15;stickySideBarElem.style.top=t+"px"}else stickySideBarElem.style.top="50px"</script></div><footer><div class=text-center><div class="text-center pt-2"><span class=px-1><a href=https://github.com/GGP1 aria-label=github><svg width="2.7em" height="2.7em" viewBox="0 0 1792 1792"><path id="footer-socialNetworks-github-svg-path" d="M522 1352q-8 9-20-3-13-11-4-19 8-9 20 3 12 11 4 19zm-42-61q9 12 0 19-8 6-17-7t0-18q9-7 17 6zm-61-60q-5 7-13 2-10-5-7-12 3-5 13-2 10 5 7 12zm31 34q-6 7-16-3-9-11-2-16 6-6 16 3 9 11 2 16zm129 112q-4 12-19 6-17-4-13-15t19-7q16 5 13 16zm63 5q0 11-16 11-17 2-17-11 0-11 16-11 17-2 17 11zm58-10q2 10-14 14t-18-8 14-15q16-2 18 9zm964-956v960q0 119-84.5 203.5T1376 1664h-224q-16 0-24.5-1t-19.5-5-16-14.5-5-27.5v-239q0-97-52-142 57-6 102.5-18t94-39 81-66.5 53-105T1386 856q0-121-79-206 37-91-8-204-28-9-81 11t-92 44l-38 24q-93-26-192-26t-192 26q-16-11-42.5-27T578 459.5 492 446q-44 113-7 204-79 85-79 206 0 85 20.5 150t52.5 105 80.5 67 94 39 102.5 18q-40 36-49 103-21 10-45 15t-57 5-65.5-21.5T484 1274q-19-32-48.5-52t-49.5-24l-20-3q-21 0-29 4.5t-5 11.5 9 14 13 12l7 5q22 10 43.5 38t31.5 51l10 23q13 38 44 61.5t67 30 69.5 7 55.5-3.5l23-4q0 38 .5 103t.5 68q0 22-11 33.5t-22 13-33 1.5H416q-119 0-203.5-84.5T128 1376V416q0-119 84.5-203.5T416 128h960q119 0 203.5 84.5T1664 416z"/></svg>
</a></span><span class=px-1><a href=https://linkedin.com/in/gastonpalomeque aria-label=linkedin><svg width="2.4em" height="2.4em" fill="#fff" aria-label="LinkedIn" viewBox="0 0 512 512"><rect width="512" height="512" fill="#0077b5" rx="15%"/><circle cx="142" cy="138" r="37"/><path stroke="#fff" stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
</a></span><span class=px-1><a href=https://stackoverflow.com/users/12574067/ggp aria-label=stackoverflow><svg viewBox="-24 0 304 304" width="1.8em" height="1.8em" xmlns:xlink="http://www.w3.org/1999/xlink" preserveAspectRatio="xMidYMid" fill="#000"><g id="SVGRepo_bgCarrier" stroke-width="0"/><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"/><g id="SVGRepo_iconCarrier"><g><polygon fill="#bcbbbb" points="216.329708 276.187929 216.329708 194.976776 243.28341 194.976776 243.28341 303.14163 0 303.14163 0 194.976776 26.9537015 194.976776 26.9537015 276.187929"/><path d="M56.7077876 187.275718 189.025959 214.929516 194.626728 188.325863 62.3085568 160.672065l-5.6007692 26.603653zm17.5024036-63.008653L196.727016 181.324901l11.201539-24.503365L85.4117295 99.4136524 74.2101912 124.267065zM108.164854 64.0587971 212.129132 150.520671l17.152355-20.652836L125.31721 43.4059609 108.164854 64.0587971zM175.374084.0l-21.70298 16.1022113L234.18216 124.617114l21.70298-16.102212L175.374084.0zM53.9074031 248.884179H189.025959V221.930478H53.9074031v26.953701z" fill="#f48023"/></g></g></svg></a></span></div><div class=py-3>Gastón Palomeque</div></div></footer><script src=/bootstrap-5/js/bootstrap.bundle.min.js></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))});var tooltipTriggerList=[].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')),tooltipList=tooltipTriggerList.map(function(e){return new bootstrap.Tooltip(e)})</script><script src=/js/search.js></script><section id=search-content class=py-2><div class=container id=search-results></div></section></body></html>