<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Mastering SQL with Go - Part 1 | Gastón Palomeque</title><meta name=keywords content>
<meta name=description content="I found myself using SQL a lot in one of my projects and I have learnt many things while trying to solve the problems I encountered.
This post is the part one of a series where I will try to show how to manage data in a relational database using SQL (Postgre syntax), Go and its standard library package database/sql.
Explaining absolutely everything would require an entire book so I will skip the subjects that most articles already cover (connection establishment, foreign keys, parameterized arguments, etc).">
<meta name=author content>
<link rel=canonical href=https://ggp1.github.io/posts/mastering_sql_with_go_p1/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.15f3f69b5a510ba11e60d2a099f0f25695a8b6148a1422fb5ef6e357d5f8c47c.css integrity="sha256-FfP2m1pRC6EeYNKgmfDyVpWothSKFCL7XvbjV9X4xHw=" rel="preload stylesheet" as=style>
<link rel=preload href=/apple-touch-icon.png as=image>
<link rel=icon href=https://ggp1.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://ggp1.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://ggp1.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://ggp1.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://ggp1.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.93.0">
<meta property="og:title" content="Mastering SQL with Go - Part 1">
<meta property="og:description" content="I found myself using SQL a lot in one of my projects and I have learnt many things while trying to solve the problems I encountered.
This post is the part one of a series where I will try to show how to manage data in a relational database using SQL (Postgre syntax), Go and its standard library package database/sql.
Explaining absolutely everything would require an entire book so I will skip the subjects that most articles already cover (connection establishment, foreign keys, parameterized arguments, etc).">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ggp1.github.io/posts/mastering_sql_with_go_p1/"><meta property="og:image" content="https://ggp1.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-17T00:00:00+00:00">
<meta property="article:modified_time" content="2022-01-17T00:00:00+00:00"><meta property="og:site_name" content="Gastón Palomeque">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://ggp1.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Mastering SQL with Go - Part 1">
<meta name=twitter:description content="I found myself using SQL a lot in one of my projects and I have learnt many things while trying to solve the problems I encountered.
This post is the part one of a series where I will try to show how to manage data in a relational database using SQL (Postgre syntax), Go and its standard library package database/sql.
Explaining absolutely everything would require an entire book so I will skip the subjects that most articles already cover (connection establishment, foreign keys, parameterized arguments, etc).">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ggp1.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Mastering SQL with Go - Part 1","item":"https://ggp1.github.io/posts/mastering_sql_with_go_p1/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Mastering SQL with Go - Part 1","name":"Mastering SQL with Go - Part 1","description":"I found myself using SQL a lot in one of my projects and I have learnt many things while trying to solve the problems I encountered.\nThis post is the part one of a series where I will try to show how to manage data in a relational database using SQL (Postgre syntax), Go and its standard library package database/sql.\nExplaining absolutely everything would require an entire book so I will skip the subjects that most articles already cover (connection establishment, foreign keys, parameterized arguments, etc).","keywords":[],"articleBody":"I found myself using SQL a lot in one of my projects and I have learnt many things while trying to solve the problems I encountered.\nThis post is the part one of a series where I will try to show how to manage data in a relational database using SQL (Postgre syntax), Go and its standard library package database/sql.\nExplaining absolutely everything would require an entire book so I will skip the subjects that most articles already cover (connection establishment, foreign keys, parameterized arguments, etc).\nConnection tuning When we connect to an SQL database through a driver and using the database/sql package we get the sql.DB database handle, which manages a pool of active connections that are safe for concurrent use, creating new ones when required.\n To perform actions on a dedicated connection, we can use sql.Conn.\n The management of these connections can be personalized by using the following methods:\n// Set the maximum number of concurrent open connections. // There is no limit defined by default. // After the limit is passed, new datatabase operations will block // until there's an available connection. db.SetMaxOpenConns(n int)  // Set a connection's maximum life time. // Default is 2. // Increasing this value will improve the database performance at the // cost of consuming more memory to keep the connections alive. db.SetMaxIdleConns(n int)  // Set a connection's maximum life time, once the time is reached it // cannot be used again. // By default connections are reused forever. // Every one second the `database/sql` package removes expired connections // from the pool. db.SetConnMaxLifetime(d time.Duration)  // Set a connection's maximum idle time. // No value is set by default, connections may be idle their entire lifetime. db.SetConnMaxIdleTime(d time.Duration) The recommended values for these configurations depend on the type of application the database is used for, it may be convenient to specify and tweak them on the fly based on metrics gathered.\nI personally prefer to begin limiting the maximum number and time of idle connections to avoid holding them for a long period of time (i.e. a burst of requests may open many connections that later won’t be used anymore).\n A simple and useful way of getting more information about the database connection is the db.Stats() method.\n Scan null values If we attempt to scan a null value into a non-pointer variable we will receive an error saying that a null value can’t be scanned into a Go type. There are (at least) three ways to address this problem:\nCOALESCE The COALESCE function takes n arguments and returns the first one that is not null, hence, we can use the targeted field as the first argument and then a default value to be returned when the first one is null.\n COALESCE provides the same functionality as NVL or IFNULL from the SQL-standard.\n The query would be as follows:\n\"SELECT COALESCE(description, '') as description FROM posts WHERE id='sample\" Standard library types The database/sql package has various types for scanning potentially null values (sql.NullString, sql.NullInt, sql.NullBool, etc.)\n// SELECT description FROM posts WHERE id='sample'; func scanString(row *sql.Row) (string, error) { \tvar nullable sql.NullString \tif err := row.Scan(\u0026nullable); err != nil { \treturn \"\", err \t} \t// We can check if the value is null by using the nullable.Valid field. \tif !nullable.Valid { \t// nullable is null \t}  \treturn nullable.String, nil } Pointers The last option, and probably the most used one, is to declare a pointer that will be equal to nil in case there is no value stored.\n// SELECT description FROM posts WHERE id='sample'; func scanString(row *sql.Row) (*string, error) { \tvar nullable *string \tif err := row.Scan(\u0026nullable); err != nil { \treturn \"\", err \t}  \treturn nullable, nil } Storing slices Storing a list of items that correspond to an object is generally done by using a new table and a foreign key to link both records.\nHowever, in the case of simple data types like text and integer we can use text[] and integer[] respectively.\nThis isn’t only simpler but it doesn’t require to create a new table and one new row per slice element.\n For further information, see the official docs.\n Let’s take a look at how to store a string slice in PostgreSQL with Go:\n// Package \"github.com/lib/pq\" required // // `keys` field is of type text[] func insertKeys(db *sql.DB, id string, keys pq.StringArray) error { \t_, err := db.Exec(\"INSERT INTO users (keys) VALUES ($2) WHERE id=$1\", id, keys) \tif err != nil { \treturn err \t} \treturn nil }  // pq.StringArray underlying type is []string func getKeys(db *sql.DB, id string) ([]string, error) { \trow := db.QueryRow(\"SELECT keys FROM users WHERE id=$1\", id) \tvar keys pq.StringArray \tif err := row.Scan(\u0026keys); err != nil { \treturn nil, err \t} \treturn keys, nil } Update only what changes The COALESCE function we’ve seen above is also handy for updating only the fields that the user specified a value for.\nConsider a scenario where we want the users to update a post’s content, the image or both.\nWe will use string pointers for our struct fields to distinguish null values, otherwise we wouldn’t know whether the user wants to store and empty string or to not change anything.\ntype UpdatePost struct { \tContent *string \tImage *string }  func updatePost(db *sql.DB, id string, post UpdatePost) error { \tq := `UPDATE posts SET content = COALESCE($2, content) image = COALESCE($3, image) WHERE id = $1` \t_, err := db.Exec(q, id, post.Content, post.Image) \treturn err } This way, if the user updated the content only, COALESCE will detect that the image argument is null and thus use the already stored value, leaving the field as it was prior to the update.\nBatch inserts Inserting multiple records at once is typically an expensive operation and that’s why we need an optimal solution for it.\nBulk imports - COPY command The COPY command is optimized for loading large numbers of rows; it is less flexible than INSERT, but incurs significantly less overhead for large data loads.\nSince it’s a single command, there is no need to disable autocommit if you use this method to populate a table. Also, it stops operation at the first error.\nCOPY FROM will invoke any triggers and check constraints on the destination table. However, it will not invoke rules.\nfunc bulkImports(db *sql.DB, posts []Post) error { \tstmt, err := db.Prepare(\"COPY posts (id, title, content) FROM STDIN\") \tif err != nil { \treturn err \t} \tdefer stmt.Close() \t\tfor _, post := range posts { \t_, err := stmt.ExecContext(ctx, post.ID, post.Title, post.Content) \tif err != nil { \treturn err \t} \t} \t\t// Flush buffered data \tif _, err := stmt.ExecContext(ctx); err != nil { \treturn err \t}  \treturn nil } Query building Another way to insert multiple records in one call is to build a query containing a set of arguments for each of them.\nFor example:\n\"INSERT INTO posts (id, title, content, image) VALUES ($1, $2, $3), ($4, $5, $6)\"  Take a look at the implementation here.\nNote that the maximum number of arguments supported by VALUES is 1000.\n Pagination Pagination is the process of dividing a document into discrete pages.\nIn programming, we provide our clients the possibility to paginate the list of results by using a cursor.\nA cursor could be thought as a flag that divides already seen records and not yet seen ones.\nOn each request, we return a new cursor (which may be an id or an encoded string) so the user can ask for more records without getting repeated ones.\nHere are two common ways of implementing pagination in SQL that are safe from injection:\nUsing UUIDs We select the posts that were created before the date passed, in case the date matches with the creation timestamp, the ID is compared.\n In this case, the cursor is generally an encoded string that contains both the ID and the creation timestamp.\n // Requires the table to have a field with a timestamp of the value creation id := \"3c0217ac-503f-45dc-b150-0b1618155d3d\" createdAt := time.Now() q := `SELECT * FROM posts WHERE created_at ORDER BY created_at DESC, id DESC LIMIT 5` db.Query(q, createdAt, id) Using lexicographically sortable IDs Since the IDs are already sorted there is no need to compare the creation date, the ID is the cursor itself.\nid := \"01FMA344NAGPSKF4TNAXMC06KS\" db.Query(\"SELECT * FROM posts WHERE id , id) Prepared statements When we make a query using db.Query(), a prepared statement is built underneath to run it, but it’s used only once.\nIf we were to execute the same query multiple times, we would be wasting resources as the prepared statement would be compiled on each iteration.\nIn order to fix this, we can use prepared statements, they allow us to compile the query with parameterized arguments separetely and then use that statement n times.\nAnother advantage is that multiple queries or executions may be run concurrently from the returned statement.\nstmt, err := db.Prepare(\"SELECT * FROM posts WHERE id=$1\") if err != nil { \treturn err } // Remember to always close the statement when // it's no longer needed to free up resources defer stmt.Close()  for _, id := range postIDs { \tif _, err := stmt.QueryRowContext(ctx, id); err != nil { \treturn err \t} \t// Scan post } Stored procedures Stored procedures are user-defined functions that can be stored in the database for later reuse, they can contain parameters but can’t return anything.\nAs simple as that, let’s implement a stored procedure for updating a post’s likes:\n// Check if the user already liked the post, if yes, remove the like, if not, add it. q := `CREATE OR REPLACE PROCEDURE likePost(postID text, userID text) AS $$ BEGIN IF EXISTS (SELECT 1 FROM post_likes WHERE post_id=postID AND user_id=userID) THEN DELETE FROM post_likes WHERE post_id=postID AND user_id=userID; ELSE INSERT INTO post_likes (post_id, user_id) VALUES (postID, userID); END IF; END $$ LANGUAGE plpgsql` db.ExecContext(ctx, q) We can execute it doing:\ndb.ExecContext(ctx, \"CALL likePost($1, $2)\", postID, userID) Parting words I hope you found this post useful, in the next one we will be taking a look at transactions (propagation using context and isolation levels), dynamic scanning, full text search, recursive queries and much more.\n","wordCount":"1711","inLanguage":"en","datePublished":"2022-01-17T00:00:00Z","dateModified":"2022-01-17T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ggp1.github.io/posts/mastering_sql_with_go_p1/"},"publisher":{"@type":"Organization","name":"Gastón Palomeque","logo":{"@type":"ImageObject","url":"https://ggp1.github.io/favicon.ico"}}}</script>
</head><body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header>
<nav class=nav>
<div class=logo>
<a href=https://ggp1.github.io/ accesskey=h title=" (Alt + H)">
<img src=/apple-touch-icon.png alt=logo aria-label=logo height=38></a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div><ul id=menu>
<li>
<a href=https://ggp1.github.io/ title=home>
<span>home</span>
</a>
</li><li>
<a href=https://ggp1.github.io/projects/ title=projects>
<span>projects</span>
</a>
</li><li>
<a href=https://ggp1.github.io/posts/ title=posts>
<span>posts</span>
</a>
</li><li>
<a href=https://ggp1.github.io/about/ title=about>
<span>about</span>
</a>
</li></ul></nav></header><main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://ggp1.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ggp1.github.io/posts/>Posts</a></div><h1 class=post-title>
Mastering SQL with Go - Part 1
</h1><div class=post-meta>January 17, 2022
</div></header><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<div class=details>Table of Contents</div></summary>
<div class=inner><ul>
<li>
<a href=#connection-tuning aria-label="Connection tuning">Connection tuning</a></li><li>
<a href=#scan-null-values aria-label="Scan null values">Scan null values</a><ul>
<li>
<a href=#coalesce aria-label=COALESCE>COALESCE</a></li><li>
<a href=#standard-library-types aria-label="Standard library types">Standard library types</a></li><li>
<a href=#pointers aria-label=Pointers>Pointers</a></li></ul></li><li>
<a href=#storing-slices aria-label="Storing slices">Storing slices</a></li><li>
<a href=#update-only-what-changes aria-label="Update only what changes">Update only what changes</a></li><li>
<a href=#batch-inserts aria-label="Batch inserts">Batch inserts</a><ul>
<li>
<a href=#bulk-imports---copy-command aria-label="Bulk imports - COPY command">Bulk imports - COPY command</a></li><li>
<a href=#query-building aria-label="Query building">Query building</a></li></ul></li><li>
<a href=#pagination aria-label=Pagination>Pagination</a><ul>
<li>
<a href=#using-uuids aria-label="Using UUIDs">Using UUIDs</a></li><li>
<a href=#using-lexicographically-sortable-ids aria-label="Using lexicographically sortable IDs">Using lexicographically sortable IDs</a></li></ul></li><li>
<a href=#prepared-statements aria-label="Prepared statements">Prepared statements</a></li><li>
<a href=#stored-procedures aria-label="Stored procedures">Stored procedures</a></li><li>
<a href=#parting-words aria-label="Parting words">Parting words</a>
</li></ul></div></details>
</div><div class=post-content><p>I found myself using SQL a lot in one of my projects and I have learnt many things while trying to solve the problems I encountered.</p><p>This post is the part one of a series where I will try to show how to manage data in a relational database using SQL (Postgre syntax), Go and its standard library package <a href=https://github.com/golang/go/tree/master/src/database/sql><code>database/sql</code></a>.</p><p>Explaining absolutely everything would require an entire book so I will skip the subjects that most articles already cover (connection establishment, foreign keys, parameterized arguments, etc).</p><h3 id=connection-tuning>Connection tuning<a hidden class=anchor aria-hidden=true href=#connection-tuning>#</a></h3><p>When we connect to an SQL database through a driver and using the <code>database/sql</code> package we get the <a href=https://pkg.go.dev/database/sql#DB><code>sql.DB</code></a> database handle, which manages a pool of active connections that are safe for concurrent use, creating new ones when required.</p><blockquote>
<p>To perform actions on a dedicated connection, we can use <a href=https://pkg.go.dev/database/sql#Conn><code>sql.Conn</code></a>.</p></blockquote><p>The management of these connections can be personalized by using the following methods:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Set the maximum number of concurrent open connections.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// There is no limit defined by default.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// After the limit is passed, new datatabase operations will block 
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// until there&#39;s an available connection.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>db.<span style=color:#50fa7b>SetMaxOpenConns</span>(n <span style=color:#8be9fd>int</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Set a connection&#39;s maximum life time.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Default is 2.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Increasing this value will improve the database performance at the
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// cost of consuming more memory to keep the connections alive.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>db.<span style=color:#50fa7b>SetMaxIdleConns</span>(n <span style=color:#8be9fd>int</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Set a connection&#39;s maximum life time, once the time is reached it 
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// cannot be used again.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// By default connections are reused forever.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Every one second the `database/sql` package removes expired connections 
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// from the pool.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>db.<span style=color:#50fa7b>SetConnMaxLifetime</span>(d time.Duration)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Set a connection&#39;s maximum idle time.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// No value is set by default, connections may be idle their entire lifetime.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>db.<span style=color:#50fa7b>SetConnMaxIdleTime</span>(d time.Duration) 
</span></span></code></pre></div><p>The recommended values for these configurations depend on the type of application the database is used for, it may be convenient to specify and tweak them on the fly based on metrics gathered.</p><p>I personally prefer to begin limiting the maximum number and time of <strong>idle</strong> connections to avoid holding them for a long period of time (i.e. a burst of requests may open many connections that later won&rsquo;t be used anymore).</p><blockquote>
<p>A simple and useful way of getting more information about the database connection is the <a href=https://pkg.go.dev/database/sql#DB.Stats><code>db.Stats()</code></a> method.</p></blockquote><h3 id=scan-null-values>Scan null values<a hidden class=anchor aria-hidden=true href=#scan-null-values>#</a></h3><p>If we attempt to scan a null value into a non-pointer variable we will receive an error saying that a null value can&rsquo;t be scanned into a Go type. There are (at least) three ways to address this problem:</p><h4 id=coalesce>COALESCE<a hidden class=anchor aria-hidden=true href=#coalesce>#</a></h4><p>The <em>COALESCE</em> function takes <em>n</em> arguments and returns the first one that is not null, hence, we can use the targeted field as the first argument and then a default value to be returned when the first one is null.</p><blockquote>
<p>COALESCE provides the same functionality as NVL or IFNULL from the SQL-standard.</p></blockquote><p>The query would be as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f1fa8c>&#34;SELECT COALESCE(description, &#39;&#39;) as description FROM posts WHERE id=&#39;sample&#34;</span>
</span></span></code></pre></div><h4 id=standard-library-types>Standard library types<a hidden class=anchor aria-hidden=true href=#standard-library-types>#</a></h4><p>The <code>database/sql</code> package has various types for scanning potentially null values (<code>sql.NullString</code>, <code>sql.NullInt</code>, <code>sql.NullBool</code>, etc.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// SELECT description FROM posts WHERE id=&#39;sample&#39;;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>scanString</span>(row <span style=color:#ff79c6>*</span>sql.Row) (<span style=color:#8be9fd>string</span>, <span style=color:#8be9fd>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> nullable sql.NullString
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> row.<span style=color:#50fa7b>Scan</span>(<span style=color:#ff79c6>&amp;</span>nullable); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>&#34;&#34;</span>, err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// We can check if the value is null by using the nullable.Valid field.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> !nullable.Valid {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// nullable is null
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> nullable.String, <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=pointers>Pointers<a hidden class=anchor aria-hidden=true href=#pointers>#</a></h4><p>The last option, and probably the most used one, is to declare a pointer that will be equal to <code>nil</code> in case there is no value stored.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// SELECT description FROM posts WHERE id=&#39;sample&#39;;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>scanString</span>(row <span style=color:#ff79c6>*</span>sql.Row) (<span style=color:#ff79c6>*</span><span style=color:#8be9fd>string</span>, <span style=color:#8be9fd>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> nullable <span style=color:#ff79c6>*</span><span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> row.<span style=color:#50fa7b>Scan</span>(<span style=color:#ff79c6>&amp;</span>nullable); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>&#34;&#34;</span>, err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> nullable, <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=storing-slices>Storing slices<a hidden class=anchor aria-hidden=true href=#storing-slices>#</a></h3><p>Storing a list of items that correspond to an object is generally done by using a new table and a foreign key to link both records.</p><p>However, in the case of simple data types like text and integer we can use <code>text[]</code> and <code>integer[]</code> respectively.</p><p>This isn&rsquo;t only simpler but it doesn&rsquo;t require to create a new table and one new row per slice element.</p><blockquote>
<p>For further information, see the <a href=https://www.postgresql.org/docs/14/arrays.html>official docs</a>.</p></blockquote><p>Let&rsquo;s take a look at how to store a string slice in PostgreSQL with Go:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Package &#34;github.com/lib/pq&#34; required
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// `keys` field is of type text[]
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>insertKeys</span>(db <span style=color:#ff79c6>*</span>sql.DB, id <span style=color:#8be9fd>string</span>, keys pq.StringArray) <span style=color:#8be9fd>error</span> {
</span></span><span style=display:flex><span>	_, err <span style=color:#ff79c6>:=</span> db.<span style=color:#50fa7b>Exec</span>(<span style=color:#f1fa8c>&#34;INSERT INTO users (keys) VALUES ($2) WHERE id=$1&#34;</span>, id, keys)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// pq.StringArray underlying type is []string
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>getKeys</span>(db <span style=color:#ff79c6>*</span>sql.DB, id <span style=color:#8be9fd>string</span>) ([]<span style=color:#8be9fd>string</span>, <span style=color:#8be9fd>error</span>) {
</span></span><span style=display:flex><span>	row <span style=color:#ff79c6>:=</span> db.<span style=color:#50fa7b>QueryRow</span>(<span style=color:#f1fa8c>&#34;SELECT keys FROM users WHERE id=$1&#34;</span>, id)
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> keys pq.StringArray
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> row.<span style=color:#50fa7b>Scan</span>(<span style=color:#ff79c6>&amp;</span>keys); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> keys, <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=update-only-what-changes>Update only what changes<a hidden class=anchor aria-hidden=true href=#update-only-what-changes>#</a></h3><p>The <a href=#coalesce>COALESCE</a> function we&rsquo;ve seen above is also handy for updating only the fields that the user specified a value for.</p><p>Consider a scenario where we want the users to update a post&rsquo;s content, the image or both.</p><p>We will use string pointers for our struct fields to distinguish null values, otherwise we wouldn&rsquo;t know whether the user wants to store and empty string or to not change anything.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> UpdatePost <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>	Content <span style=color:#ff79c6>*</span><span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>	Image <span style=color:#ff79c6>*</span><span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>updatePost</span>(db <span style=color:#ff79c6>*</span>sql.DB, id <span style=color:#8be9fd>string</span>, post UpdatePost) <span style=color:#8be9fd>error</span> {
</span></span><span style=display:flex><span>	q <span style=color:#ff79c6>:=</span> <span style=color:#f1fa8c>`UPDATE posts SET 
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	content = COALESCE($2, content)
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	image = COALESCE($3, image)
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	WHERE id = $1`</span>
</span></span><span style=display:flex><span>	_, err <span style=color:#ff79c6>:=</span> db.<span style=color:#50fa7b>Exec</span>(q, id, post.Content, post.Image)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This way, if the user updated the content only, COALESCE will detect that the image argument is null and thus use the already stored value, leaving the field as it was prior to the update.</p><h3 id=batch-inserts>Batch inserts<a hidden class=anchor aria-hidden=true href=#batch-inserts>#</a></h3><p>Inserting multiple records at once is typically an expensive operation and that&rsquo;s why we need an optimal solution for it.</p><h4 id=bulk-imports---copy-command>Bulk imports - COPY command<a hidden class=anchor aria-hidden=true href=#bulk-imports---copy-command>#</a></h4><p>The <code>COPY</code> command is optimized for loading large numbers of rows; it is less flexible than <code>INSERT</code>, but incurs significantly less overhead for large data loads.</p><p>Since it&rsquo;s a single command, there is no need to disable autocommit if you use this method to populate a table. Also, it stops operation at the first error.</p><p><code>COPY FROM</code> will invoke any triggers and check constraints on the destination table. However, it will not invoke rules.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>bulkImports</span>(db <span style=color:#ff79c6>*</span>sql.DB, posts []Post) <span style=color:#8be9fd>error</span> {
</span></span><span style=display:flex><span>	stmt, err <span style=color:#ff79c6>:=</span> db.<span style=color:#50fa7b>Prepare</span>(<span style=color:#f1fa8c>&#34;COPY posts (id, title, content) FROM STDIN&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>defer</span> stmt.<span style=color:#50fa7b>Close</span>()
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> _, post <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> posts {
</span></span><span style=display:flex><span>		_, err <span style=color:#ff79c6>:=</span> stmt.<span style=color:#50fa7b>ExecContext</span>(ctx, post.ID, post.Title, post.Content)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Flush buffered data
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> _, err <span style=color:#ff79c6>:=</span> stmt.<span style=color:#50fa7b>ExecContext</span>(ctx); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=query-building>Query building<a hidden class=anchor aria-hidden=true href=#query-building>#</a></h4><p>Another way to insert multiple records in one call is to build a query containing a set of arguments for each of them.</p><p>For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f1fa8c>&#34;INSERT INTO posts (id, title, content, image) VALUES ($1, $2, $3), ($4, $5, $6)&#34;</span>
</span></span></code></pre></div><blockquote>
<p>Take a look at the implementation <a href=https://stackoverflow.com/questions/12486436/how-do-i-batch-sql-statements-with-package-database-sql>here</a>.</p><p>Note that the maximum number of arguments supported by <code>VALUES</code> is 1000.</p></blockquote><h3 id=pagination>Pagination<a hidden class=anchor aria-hidden=true href=#pagination>#</a></h3><p>Pagination is the process of dividing a document into discrete pages.</p><p>In programming, we provide our clients the possibility to paginate the list of results by using a cursor.</p><p>A cursor could be thought as a flag that divides already seen records and not yet seen ones.</p><p>On each request, we return a new cursor (which may be an id or an encoded string) so the user can ask for more records without getting repeated ones.</p><p>Here are two common ways of implementing pagination in SQL that are safe from injection:</p><h4 id=using-uuids>Using UUIDs<a hidden class=anchor aria-hidden=true href=#using-uuids>#</a></h4><p>We select the posts that were created before the date passed, in case the date matches with the creation timestamp, the ID is compared.</p><blockquote>
<p>In this case, the cursor is generally an encoded string that contains both the ID and the creation timestamp.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Requires the table to have a field with a timestamp of the value creation
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>id <span style=color:#ff79c6>:=</span> <span style=color:#f1fa8c>&#34;3c0217ac-503f-45dc-b150-0b1618155d3d&#34;</span>
</span></span><span style=display:flex><span>createdAt <span style=color:#ff79c6>:=</span> time.<span style=color:#50fa7b>Now</span>()
</span></span><span style=display:flex><span>q <span style=color:#ff79c6>:=</span> <span style=color:#f1fa8c>`SELECT * FROM posts WHERE 
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>created_at &lt; $1 OR (created_at = $1 AND id &lt; $2) 
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>ORDER BY created_at DESC, id DESC LIMIT 5`</span>
</span></span><span style=display:flex><span>db.<span style=color:#50fa7b>Query</span>(q, createdAt, id)
</span></span></code></pre></div><h4 id=using-lexicographically-sortable-ids>Using lexicographically sortable IDs<a hidden class=anchor aria-hidden=true href=#using-lexicographically-sortable-ids>#</a></h4><p>Since the IDs are already sorted there is no need to compare the creation date, the ID is the cursor itself.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>id <span style=color:#ff79c6>:=</span> <span style=color:#f1fa8c>&#34;01FMA344NAGPSKF4TNAXMC06KS&#34;</span>
</span></span><span style=display:flex><span>db.<span style=color:#50fa7b>Query</span>(<span style=color:#f1fa8c>&#34;SELECT * FROM posts WHERE id &lt; $1 ORDER BY id DESC LIMIT 5&#34;</span>, id)
</span></span></code></pre></div><h3 id=prepared-statements>Prepared statements<a hidden class=anchor aria-hidden=true href=#prepared-statements>#</a></h3><p>When we make a query using <a href=https://pkg.go.dev/database/sql#DB.Query><code>db.Query()</code></a>, a prepared statement is built underneath to run it, but it&rsquo;s used only once.</p><p>If we were to execute the same query multiple times, we would be wasting resources as the prepared statement would be compiled on each iteration.</p><p>In order to fix this, we can use <em>prepared statements</em>, they allow us to compile the query with parameterized arguments separetely and then use that statement <em>n</em> times.</p><p>Another advantage is that multiple queries or executions may be run concurrently from the returned statement.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>stmt, err <span style=color:#ff79c6>:=</span> db.<span style=color:#50fa7b>Prepare</span>(<span style=color:#f1fa8c>&#34;SELECT * FROM posts WHERE id=$1&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>// Remember to always close the statement when 
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// it&#39;s no longer needed to free up resources
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>defer</span> stmt.<span style=color:#50fa7b>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> _, id <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> postIDs {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> _, err <span style=color:#ff79c6>:=</span> stmt.<span style=color:#50fa7b>QueryRowContext</span>(ctx, id); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Scan post
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><h3 id=stored-procedures>Stored procedures<a hidden class=anchor aria-hidden=true href=#stored-procedures>#</a></h3><p>Stored procedures are user-defined functions that can be stored in the database for later reuse, they can contain parameters but can&rsquo;t return anything.</p><p>As simple as that, let&rsquo;s implement a stored procedure for updating a post&rsquo;s likes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Check if the user already liked the post, if yes, remove the like, if not, add it.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>q <span style=color:#ff79c6>:=</span> <span style=color:#f1fa8c>`CREATE OR REPLACE PROCEDURE likePost(postID text, userID text) AS $$
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	BEGIN
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>		IF EXISTS (SELECT 1 FROM post_likes WHERE post_id=postID AND user_id=userID) THEN
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	   		DELETE FROM post_likes WHERE post_id=postID AND user_id=userID;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	   	ELSE
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	   		INSERT INTO post_likes (post_id, user_id) VALUES (postID, userID);
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	   	END IF;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	END 
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>$$ LANGUAGE plpgsql`</span>
</span></span><span style=display:flex><span>db.<span style=color:#50fa7b>ExecContext</span>(ctx, q)
</span></span></code></pre></div><p>We can execute it doing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>db.<span style=color:#50fa7b>ExecContext</span>(ctx, <span style=color:#f1fa8c>&#34;CALL likePost($1, $2)&#34;</span>, postID, userID)
</span></span></code></pre></div><h3 id=parting-words>Parting words<a hidden class=anchor aria-hidden=true href=#parting-words>#</a></h3><p>I hope you found this post useful, in the next one we will be taking a look at transactions (propagation using context and isolation levels), dynamic scanning, full text search, recursive queries and much more.</p></div><footer class=post-footer>
<nav class=paginav>
<a class=next href=https://ggp1.github.io/posts/rn_generic_list/>
<span class=title>Next Page »</span>
<br>
<span>React Native generic list</span>
</a>
</nav></footer></article></main><footer class=footer>
<span>&copy; 2022 &#183; Gastón Palomeque</span>
</footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script>
</body></html>