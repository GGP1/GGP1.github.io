<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>React Native generic list | Gastón Palomeque</title>
<meta name=keywords content>
<meta name=description content="React Native&rsquo;s FlatList is a component that supports many cool features while being simple and easy to use, it&rsquo;s a good example of a well-designed piece of software and that&rsquo;s why I decided to take it a step further.
For that, I&rsquo;ve developed a generic list built on top of it that handles pagination and refreshing internally, reducing a lot of repetitive code from my previous implementation.
I looked for something like this online but couldn&rsquo;t find anything similar, even though it might be useful for many people, so I decided to share it.">
<meta name=author content>
<link rel=canonical href=https://ggp1.github.io/posts/rn_generic_list/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.15f3f69b5a510ba11e60d2a099f0f25695a8b6148a1422fb5ef6e357d5f8c47c.css integrity="sha256-FfP2m1pRC6EeYNKgmfDyVpWothSKFCL7XvbjV9X4xHw=" rel="preload stylesheet" as=style>
<link rel=preload href=/apple-touch-icon.png as=image>
<link rel=icon href=https://ggp1.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://ggp1.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://ggp1.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://ggp1.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://ggp1.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.2">
<meta property="og:title" content="React Native generic list">
<meta property="og:description" content="React Native&rsquo;s FlatList is a component that supports many cool features while being simple and easy to use, it&rsquo;s a good example of a well-designed piece of software and that&rsquo;s why I decided to take it a step further.
For that, I&rsquo;ve developed a generic list built on top of it that handles pagination and refreshing internally, reducing a lot of repetitive code from my previous implementation.
I looked for something like this online but couldn&rsquo;t find anything similar, even though it might be useful for many people, so I decided to share it.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ggp1.github.io/posts/rn_generic_list/">
<meta property="og:image" content="https://ggp1.github.io/images/rn_list.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-12-11T00:00:00+00:00">
<meta property="article:modified_time" content="2021-12-11T00:00:00+00:00"><meta property="og:site_name" content="Gastón Palomeque">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://ggp1.github.io/images/rn_list.png">
<meta name=twitter:title content="React Native generic list">
<meta name=twitter:description content="React Native&rsquo;s FlatList is a component that supports many cool features while being simple and easy to use, it&rsquo;s a good example of a well-designed piece of software and that&rsquo;s why I decided to take it a step further.
For that, I&rsquo;ve developed a generic list built on top of it that handles pagination and refreshing internally, reducing a lot of repetitive code from my previous implementation.
I looked for something like this online but couldn&rsquo;t find anything similar, even though it might be useful for many people, so I decided to share it.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ggp1.github.io/posts/"},{"@type":"ListItem","position":2,"name":"React Native generic list","item":"https://ggp1.github.io/posts/rn_generic_list/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"React Native generic list","name":"React Native generic list","description":"React Native\u0026rsquo;s FlatList is a component that supports many cool features while being simple and easy to use, it\u0026rsquo;s a good example of a well-designed piece of software and that\u0026rsquo;s why I decided to take it a step further.\nFor that, I\u0026rsquo;ve developed a generic list built on top of it that handles pagination and refreshing internally, reducing a lot of repetitive code from my previous implementation.\nI looked for something like this online but couldn\u0026rsquo;t find anything similar, even though it might be useful for many people, so I decided to share it.","keywords":[],"articleBody":"React Native’s FlatList is a component that supports many cool features while being simple and easy to use, it’s a good example of a well-designed piece of software and that’s why I decided to take it a step further.\nFor that, I’ve developed a generic list built on top of it that handles pagination and refreshing internally, reducing a lot of repetitive code from my previous implementation.\nI looked for something like this online but couldn’t find anything similar, even though it might be useful for many people, so I decided to share it.\nHere’s the snippet with the entire code, let’s take a brief look and review it in detail later:\nimport React, { useCallback, useEffect, useState } from \"react\"; import { FlatList, FlatListProps } from \"react-native\"; interface ID { id: string } type FLPropsT = Omit FlatListPropsT, \"data\" | \"keyExtractor\" | \"onEndReached\" | \"onRefresh\" | \"refreshing\"  interface PropsT extends FLPropsT { fetchItems: (cursor?: string) = Promise[string, T[]] } export const List = T extends ID(props: PropsT) = { const [items, setItems] = useStatereadonly T[](); const [cursor, setCursor] = useStatestring(); const [refreshing, setRefreshing] = useStateboolean(false); const getItems = useCallback(async () = { try { const [nextCursor, elems] = await props.fetchItems(cursor); setCursor(nextCursor); items ? setItems(items.concat(elems)) : setItems(elems); } catch (err) { console.log(err); } finally { setRefreshing(false); } }, []); useEffect(() = { getItems(); }, []); return ( FlatList data={items} keyExtractor={item = item.id} onEndReached={({ distanceFromEnd }) = { distanceFromEnd  0 ? undefined : getItems(); }} onEndReachedThreshold={ props.onEndReachedThreshold ? props.onEndReachedThreshold : 0.1 } refreshing={refreshing} onRefresh={() = { setRefreshing(true); setCursor(undefined); setItems(undefined); getItems(); }} {...props} / ); }; List in action import { List } from \"./List\" type User = { id: string, username: string } export const UserList = () = { const getUsers = async (cursor?: string): Promise[string, User[]] = { const response = await fetch(`localhost:4000/users?cursor=${cursor}`); // In this example, the response body contains a JSON object with \t// the next cursor and an array of users \tconst json = await response.json() as {next_cursor: string, users: User[]}; return [json.next_cursor, json.users]; } return ( ListUser fetchItems={(cursor) = getUsers(cursor)} renderItem={({ item }) = ViewText{item.username}TextView} numColumns={2} // More properties from FlatList may be included here \t/ ); } As you can see, it’s extremely easy to use and requires few lines of code to have it working.\n Note two things,  makes explicit the type of items the list will contain and next_cursor must always return a non-null value, if not, the request will return duplicated items.\n Component breakdown Properties interface ID { id: string } type FLPropsT = Omit FlatListPropsT, \"data\" | \"keyExtractor\" | \"onEndReached\" | \"onRefresh\" | \"refreshing\"  interface PropsT extends FLPropsT { fetchItems: (cursor?: string) = Promise[string, T[]] } export const List = T extends ID(props: PropsT) = {} The ID interface is used for the generic to accept only items that has and id field in it, which is used to extract a unique key from each of them.\nFLProps contains all the properties of a FlatList except the ones that are specified with literal strings, preventing the caller from overwriting the properties that are automatically handled by the component.\n In my case I was always using the types' id field to uniquely identify items inside the list but if it’s not your case, keyExtractor can be delegated.\n Lastly, the component’s properties are all of FLProps plus fetchItems, the callback from which the list will be populated.\nState const [items, setItems] = useStatereadonly T[](); const [cursor, setCursor] = useStatestring(); const [refreshing, setRefreshing] = useStateboolean(false);  items holds the elements list, it’s set to read-only as the items themselves won’t be modified. Always try to type as much as possible. cursor contains the id of the element used to tell the server the starting point for a new list of elements. refreshing stores a boolean that tells whether the list is waiting for more values or not.  Get items callback const getItems = useCallback(async () = { try { const [nextCursor, elems] = await props.fetchItems(cursor); setCursor(nextCursor); items ? setItems(items.concat(elems)) : setItems(elems); } catch (err) { console.log(err); } finally { setRefreshing(false); } }, []); Here’s where most of the list’s work is done, we fetch items from a source - tipically an HTTP request to a server - using a cursor (initially undefined), so we will never get a duplicated item.\n useCallback returns a memoized version of the callback that changes only when one of its dependencies has changed.\nIn this case it has none to execute the callback only when we explicity specify it and to prevent unnecessary renders from useEffect.\n The received cursor is stored for use in following calls and, if there are already stored items, the ones from the next request are appended to them.\nAny potential error is catched and logged into the console.\nFinally, refreshing is set to false to tell the list that we are done getting new values.\nUse effect hook useEffect(() = { getItems(); }, []); useEffect runs once and gets the items that the list will contain when the component is mounted, the cursor will always be undefined.\nPagination _ onEndReached={({ distanceFromEnd }) = { distanceFromEnd  0 ? undefined : getItems(); }} onEndReachedThreshold={ props.onEndReachedThreshold ? props.onEndReachedThreshold : 0.1 } / onEndReached is the callback that will be called whenever the user reaches the end of the list, in this case it will request more items to the server, using the cursor to specify the last item of the latest response.\nThere are some scenarios when the list is first rendered but it has so few items that it triggers the onEndReached callback, forcing another render.\nIn order to avoid this, distanceFromEnd (always negative on the first render) is set to undefined in those cases.\nRefreshing _ refreshing={refreshing} onRefresh={() = { setRefreshing(true); setCursor(undefined); setItems(undefined); getItems(); }} / Each time the list is pulled the onRefresh callback is triggered.\nIn it, the list is set to its refreshing state, the component’s state is reset and new items are requested. It’s like simulating the component’s first render.\nPotential enhancements This is a simplified version of the List component I use so there are things that may be missing for your implementation.\nOne kind of obvious is the possibility that fetchItems returns undefined data.\nSome others may be:\n Passing more parameters to the fetch items callback. Set a limit to the amount of items that can be stored. Use a reference to a boolean value to avoid requesting items on an unmounted list.  Extending its utility it’s up to your imagination and I hope this post has inspired you to create useful generic components.\n","wordCount":"1100","inLanguage":"en","image":"https://ggp1.github.io/images/rn_list.png","datePublished":"2021-12-11T00:00:00Z","dateModified":"2021-12-11T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://ggp1.github.io/posts/rn_generic_list/"},"publisher":{"@type":"Organization","name":"Gastón Palomeque","logo":{"@type":"ImageObject","url":"https://ggp1.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://ggp1.github.io/ accesskey=h title=" (Alt + H)">
<img src=/apple-touch-icon.png alt=logo aria-label=logo height=38></a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://ggp1.github.io/ title=home>
<span>home</span>
</a>
</li>
<li>
<a href=https://ggp1.github.io/projects/ title=projects>
<span>projects</span>
</a>
</li>
<li>
<a href=https://ggp1.github.io/posts/ title=posts>
<span>posts</span>
</a>
</li>
<li>
<a href=https://ggp1.github.io/about/ title=about>
<span>about</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://ggp1.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ggp1.github.io/posts/>Posts</a></div>
<h1 class=post-title>
React Native generic list
</h1>
<div class=post-meta>December 11, 2021
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://ggp1.github.io/images/rn_list.png alt="React Native List example">
</figure>
<div class=post-content><p>React Native&rsquo;s <em>FlatList</em> is a component that supports many cool features while being simple and easy to use, it&rsquo;s a good example of a well-designed piece of software and that&rsquo;s why I decided to take it a step further.</p>
<p>For that, I&rsquo;ve developed a generic list built on top of it that handles <strong>pagination</strong> and <strong>refreshing</strong> internally, reducing a <em>lot</em> of repetitive code from my previous implementation.</p>
<p>I looked for something like this online but couldn&rsquo;t find anything similar, even though it might be useful for many people, so I decided to share it.</p>
<p>Here&rsquo;s the snippet with the entire code, let&rsquo;s take a brief look and review it in detail later:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=color:#ff79c6>import</span> React, { useCallback, useEffect, useState } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;react&#34;</span>;
<span style=color:#ff79c6>import</span> { FlatList, FlatListProps } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;react-native&#34;</span>;

<span style=color:#ff79c6>interface</span> ID {
	id: <span style=color:#8be9fd>string</span>
}

<span style=color:#ff79c6>type</span> FLProps&lt;<span style=color:#ff79c6>T</span>&gt; <span style=color:#ff79c6>=</span> Omit<span style=color:#ff79c6>&lt;</span>
	FlatListProps&lt;<span style=color:#ff79c6>T</span>&gt;, 
	<span style=color:#f1fa8c>&#34;data&#34;</span> <span style=color:#ff79c6>|</span> <span style=color:#f1fa8c>&#34;keyExtractor&#34;</span> <span style=color:#ff79c6>|</span> <span style=color:#f1fa8c>&#34;onEndReached&#34;</span> <span style=color:#ff79c6>|</span> <span style=color:#f1fa8c>&#34;onRefresh&#34;</span> <span style=color:#ff79c6>|</span> <span style=color:#f1fa8c>&#34;refreshing&#34;</span>
<span style=color:#ff79c6>&gt;</span>

<span style=color:#ff79c6>interface</span> Props&lt;<span style=color:#ff79c6>T</span>&gt; <span style=color:#ff79c6>extends</span> FLProps&lt;<span style=color:#ff79c6>T</span>&gt; {
	fetchItems<span style=color:#ff79c6>:</span> (cursor?: <span style=color:#8be9fd>string</span>) <span style=color:#ff79c6>=&gt;</span> Promise<span style=color:#ff79c6>&lt;</span>[<span style=color:#8be9fd>string</span>, T[]]<span style=color:#ff79c6>&gt;</span>
}

<span style=color:#ff79c6>export</span> <span style=color:#ff79c6>const</span> List <span style=color:#ff79c6>=</span> &lt;<span style=color:#ff79c6>T</span> <span style=color:#50fa7b>extends</span> <span style=color:#50fa7b>ID</span>&gt;(props: <span style=color:#8be9fd>Props</span>&lt;<span style=color:#ff79c6>T</span>&gt;) <span style=color:#ff79c6>=&gt;</span> {
	<span style=color:#ff79c6>const</span> [items, setItems] <span style=color:#ff79c6>=</span> useState&lt;<span style=color:#ff79c6>readonly</span> <span style=color:#50fa7b>T</span>[]&gt;();
	<span style=color:#ff79c6>const</span> [cursor, setCursor] <span style=color:#ff79c6>=</span> useState&lt;<span style=color:#ff79c6>string</span>&gt;();
	<span style=color:#ff79c6>const</span> [refreshing, setRefreshing] <span style=color:#ff79c6>=</span> useState&lt;<span style=color:#ff79c6>boolean</span>&gt;(<span style=color:#ff79c6>false</span>);

	<span style=color:#ff79c6>const</span> getItems <span style=color:#ff79c6>=</span> useCallback(<span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
		<span style=color:#ff79c6>try</span> {
			<span style=color:#ff79c6>const</span> [nextCursor, elems] <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> props.fetchItems(cursor);
			setCursor(nextCursor);
			items <span style=color:#ff79c6>?</span> setItems(items.concat(elems)) <span style=color:#ff79c6>:</span> setItems(elems);
		} <span style=color:#ff79c6>catch</span> (err) {
			console.log(err);
		} <span style=color:#ff79c6>finally</span> {
			setRefreshing(<span style=color:#ff79c6>false</span>);
		}
	}, []);

	useEffect(() <span style=color:#ff79c6>=&gt;</span> {
		getItems();
	}, []);

	<span style=color:#ff79c6>return</span> (
		&lt;<span style=color:#ff79c6>FlatList</span>
			<span style=color:#50fa7b>data</span><span style=color:#ff79c6>=</span>{items}
			<span style=color:#50fa7b>keyExtractor</span><span style=color:#ff79c6>=</span>{item <span style=color:#ff79c6>=&gt;</span> item.id}
			<span style=color:#50fa7b>onEndReached</span><span style=color:#ff79c6>=</span>{({ distanceFromEnd }) <span style=color:#ff79c6>=&gt;</span> {
				distanceFromEnd <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>?</span> <span style=color:#ff79c6>undefined</span> <span style=color:#ff79c6>:</span> getItems();
			}}
			<span style=color:#50fa7b>onEndReachedThreshold</span><span style=color:#ff79c6>=</span>{
				props.onEndReachedThreshold <span style=color:#ff79c6>?</span> props.onEndReachedThreshold : <span style=color:#8be9fd>0.1</span>
			}
			<span style=color:#50fa7b>refreshing</span><span style=color:#ff79c6>=</span>{refreshing}
			<span style=color:#50fa7b>onRefresh</span><span style=color:#ff79c6>=</span>{() <span style=color:#ff79c6>=&gt;</span> {
				setRefreshing(<span style=color:#ff79c6>true</span>);
				setCursor(<span style=color:#ff79c6>undefined</span>);
				setItems(<span style=color:#ff79c6>undefined</span>);
				getItems();
			}}
			{<span style=color:#50fa7b>...props</span>}
		/&gt;
	);
};
</code></pre></div><h3 id=list-in-action><code>List</code> in action<a hidden class=anchor aria-hidden=true href=#list-in-action>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=color:#ff79c6>import</span> { List } <span style=color:#ff79c6>from</span> <span style=color:#f1fa8c>&#34;./List&#34;</span>

<span style=color:#ff79c6>type</span> User <span style=color:#ff79c6>=</span> {
  id: <span style=color:#8be9fd>string</span>,
  username: <span style=color:#8be9fd>string</span>
}

<span style=color:#ff79c6>export</span> <span style=color:#ff79c6>const</span> UserList <span style=color:#ff79c6>=</span> () <span style=color:#ff79c6>=&gt;</span> {
	<span style=color:#ff79c6>const</span> getUsers <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>async</span> (cursor?: <span style=color:#8be9fd>string</span>)<span style=color:#ff79c6>:</span> Promise<span style=color:#ff79c6>&lt;</span>[<span style=color:#8be9fd>string</span>, User[]]<span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>=&gt;</span> {
		<span style=color:#ff79c6>const</span> response <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> fetch(<span style=color:#f1fa8c>`localhost:4000/users?cursor=</span><span style=color:#f1fa8c>${</span>cursor<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>`</span>);
		<span style=color:#6272a4>// In this example, the response body contains a JSON object with 
</span><span style=color:#6272a4></span>		<span style=color:#6272a4>// the next cursor and an array of users
</span><span style=color:#6272a4></span>		<span style=color:#ff79c6>const</span> json <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> response.json() <span style=color:#ff79c6>as</span> {next_cursor: <span style=color:#8be9fd>string</span>, users: <span style=color:#8be9fd>User</span>[]};
		<span style=color:#ff79c6>return</span> [json.next_cursor, json.users];
	}

	<span style=color:#ff79c6>return</span> (
		&lt;<span style=color:#ff79c6>List</span>&lt;<span style=color:#50fa7b>User</span>&gt;
			fetchItems<span style=color:#ff79c6>=</span>{(cursor) <span style=color:#ff79c6>=&gt;</span> getUsers(cursor)}
			renderItem<span style=color:#ff79c6>=</span>{({ item }) <span style=color:#ff79c6>=&gt;</span> &lt;<span style=color:#ff79c6>View</span>&gt;&lt;<span style=color:#ff79c6>Text</span>&gt;{item.username}&lt;/<span style=color:#ff79c6>Text</span>&gt;&lt;/<span style=color:#ff79c6>View</span>&gt;}
			numColumns<span style=color:#ff79c6>=</span>{<span style=color:#bd93f9>2</span>}
			<span style=color:#6272a4>// More properties from FlatList may be included here
</span><span style=color:#6272a4></span>		/&gt;
	);
}
</code></pre></div><p>As you can see, it&rsquo;s extremely easy to use and requires few lines of code to have it working.</p>
<blockquote>
<p>Note two things, <code>&lt;User></code> makes explicit the type of items the list will contain and
<code>next_cursor</code> must always return a non-null value, if not, the request will return duplicated items.</p>
</blockquote>
<h2 id=component-breakdown>Component breakdown<a hidden class=anchor aria-hidden=true href=#component-breakdown>#</a></h2>
<h3 id=properties>Properties<a hidden class=anchor aria-hidden=true href=#properties>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=color:#ff79c6>interface</span> ID {
	id: <span style=color:#8be9fd>string</span>
}

<span style=color:#ff79c6>type</span> FLProps&lt;<span style=color:#ff79c6>T</span>&gt; <span style=color:#ff79c6>=</span> Omit<span style=color:#ff79c6>&lt;</span>
	FlatListProps&lt;<span style=color:#ff79c6>T</span>&gt;, 
	<span style=color:#f1fa8c>&#34;data&#34;</span> <span style=color:#ff79c6>|</span> <span style=color:#f1fa8c>&#34;keyExtractor&#34;</span> <span style=color:#ff79c6>|</span> <span style=color:#f1fa8c>&#34;onEndReached&#34;</span> <span style=color:#ff79c6>|</span> <span style=color:#f1fa8c>&#34;onRefresh&#34;</span> <span style=color:#ff79c6>|</span> <span style=color:#f1fa8c>&#34;refreshing&#34;</span>
<span style=color:#ff79c6>&gt;</span>

<span style=color:#ff79c6>interface</span> Props&lt;<span style=color:#ff79c6>T</span>&gt; <span style=color:#ff79c6>extends</span> FLProps&lt;<span style=color:#ff79c6>T</span>&gt; {
	fetchItems<span style=color:#ff79c6>:</span> (cursor?: <span style=color:#8be9fd>string</span>) <span style=color:#ff79c6>=&gt;</span> Promise<span style=color:#ff79c6>&lt;</span>[<span style=color:#8be9fd>string</span>, T[]]<span style=color:#ff79c6>&gt;</span>
}

<span style=color:#ff79c6>export</span> <span style=color:#ff79c6>const</span> List <span style=color:#ff79c6>=</span> &lt;<span style=color:#ff79c6>T</span> <span style=color:#50fa7b>extends</span> <span style=color:#50fa7b>ID</span>&gt;(props: <span style=color:#8be9fd>Props</span>&lt;<span style=color:#ff79c6>T</span>&gt;) <span style=color:#ff79c6>=&gt;</span> {}
</code></pre></div><p>The <code>ID</code> interface is used for the generic to accept only items that has and id field in it, which is used to extract a unique key from each of them.</p>
<p><code>FLProps</code> contains all the properties of a <code>FlatList</code> except the ones that are specified with literal strings, preventing the caller from overwriting the properties that are automatically handled by the component.</p>
<blockquote>
<p>In my case I was always using the types' id field to uniquely identify items inside the list but if it&rsquo;s not your case, <code>keyExtractor</code> can be delegated.</p>
</blockquote>
<p>Lastly, the component&rsquo;s properties are all of <code>FLProps</code> plus <code>fetchItems</code>, the callback from which the list will be populated.</p>
<h3 id=state>State<a hidden class=anchor aria-hidden=true href=#state>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=color:#ff79c6>const</span> [items, setItems] <span style=color:#ff79c6>=</span> useState&lt;<span style=color:#ff79c6>readonly</span> <span style=color:#50fa7b>T</span>[]&gt;();
<span style=color:#ff79c6>const</span> [cursor, setCursor] <span style=color:#ff79c6>=</span> useState&lt;<span style=color:#ff79c6>string</span>&gt;();
<span style=color:#ff79c6>const</span> [refreshing, setRefreshing] <span style=color:#ff79c6>=</span> useState&lt;<span style=color:#ff79c6>boolean</span>&gt;(<span style=color:#ff79c6>false</span>);
</code></pre></div><ul>
<li><code>items</code> holds the elements list, it&rsquo;s set to read-only as the items themselves won&rsquo;t be modified. Always try to type as much as possible.</li>
<li><code>cursor</code> contains the id of the element used to tell the server the starting point for a new list of elements.</li>
<li><code>refreshing</code> stores a boolean that tells whether the list is waiting for more values or not.</li>
</ul>
<h3 id=get-items-callback>Get items callback<a hidden class=anchor aria-hidden=true href=#get-items-callback>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=color:#ff79c6>const</span> getItems <span style=color:#ff79c6>=</span> useCallback(<span style=color:#ff79c6>async</span> () <span style=color:#ff79c6>=&gt;</span> {
	<span style=color:#ff79c6>try</span> {
		<span style=color:#ff79c6>const</span> [nextCursor, elems] <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>await</span> props.fetchItems(cursor);
		setCursor(nextCursor);
		items <span style=color:#ff79c6>?</span> setItems(items.concat(elems)) <span style=color:#ff79c6>:</span> setItems(elems);
	} <span style=color:#ff79c6>catch</span> (err) {
		console.log(err);
	} <span style=color:#ff79c6>finally</span> {
		setRefreshing(<span style=color:#ff79c6>false</span>);
	}
}, []);
</code></pre></div><p>Here&rsquo;s where most of the list&rsquo;s work is done, we fetch items from a source - tipically an HTTP request to a server - using a cursor (initially undefined), so we will never get a duplicated item.</p>
<blockquote>
<p><code>useCallback</code> returns a memoized version of the callback that changes only when one of its dependencies has changed.</p>
<p>In this case it has none to execute the callback only when we explicity specify it and to prevent unnecessary renders from <code>useEffect</code>.</p>
</blockquote>
<p>The received cursor is stored for use in following calls and, if there are already stored items, the ones from the next request are appended to them.</p>
<p>Any potential error is catched and logged into the console.</p>
<p>Finally, <code>refreshing</code> is set to false to tell the list that we are done getting new values.</p>
<h3 id=use-effect-hook>Use effect hook<a hidden class=anchor aria-hidden=true href=#use-effect-hook>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx>useEffect(() <span style=color:#ff79c6>=&gt;</span> {
	getItems();
}, []);
</code></pre></div><p><code>useEffect</code> runs once and gets the items that the list will contain when the component is mounted, the cursor will always be undefined.</p>
<h3 id=pagination>Pagination<a hidden class=anchor aria-hidden=true href=#pagination>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx>&lt;<span style=color:#ff79c6>_</span>
	<span style=color:#50fa7b>onEndReached</span><span style=color:#ff79c6>=</span>{({ distanceFromEnd }) <span style=color:#ff79c6>=&gt;</span> {
		distanceFromEnd <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>?</span> <span style=color:#ff79c6>undefined</span> <span style=color:#ff79c6>:</span> getItems();
	}}
	<span style=color:#50fa7b>onEndReachedThreshold</span><span style=color:#ff79c6>=</span>{
		props.onEndReachedThreshold <span style=color:#ff79c6>?</span> props.onEndReachedThreshold : <span style=color:#8be9fd>0.1</span>
	}
/&gt;
</code></pre></div><p><code>onEndReached</code> is the callback that will be called whenever the user reaches the end of the list, in this case it will request more items to the server, using the cursor to specify the last item of the latest response.</p>
<p>There are some scenarios when the list is first rendered but it has so few items that it triggers the <code>onEndReached</code> callback, forcing another render.</p>
<p>In order to avoid this, <code>distanceFromEnd</code> (always negative on the first render) is set to undefined in those cases.</p>
<h3 id=refreshing>Refreshing<a hidden class=anchor aria-hidden=true href=#refreshing>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx>&lt;<span style=color:#ff79c6>_</span> 
	<span style=color:#50fa7b>refreshing</span><span style=color:#ff79c6>=</span>{refreshing}
	<span style=color:#50fa7b>onRefresh</span><span style=color:#ff79c6>=</span>{() <span style=color:#ff79c6>=&gt;</span> {
		setRefreshing(<span style=color:#ff79c6>true</span>);
		setCursor(<span style=color:#ff79c6>undefined</span>);
		setItems(<span style=color:#ff79c6>undefined</span>);
		getItems();
	}}
/&gt;
</code></pre></div><p>Each time the list is pulled the <code>onRefresh</code> callback is triggered.</p>
<p>In it, the list is set to its refreshing state, the component&rsquo;s state is reset and new items are requested. It&rsquo;s like simulating the component&rsquo;s first render.</p>
<h3 id=potential-enhancements>Potential enhancements<a hidden class=anchor aria-hidden=true href=#potential-enhancements>#</a></h3>
<p>This is a simplified version of the List component I use so there are things that may be missing for your implementation.</p>
<p>One kind of obvious is the possibility that <code>fetchItems</code> returns undefined data.</p>
<p>Some others may be:</p>
<ul>
<li>Passing more parameters to the fetch items callback.</li>
<li>Set a limit to the amount of items that can be stored.</li>
<li>Use a reference to a boolean value to avoid requesting items on an unmounted list.</li>
</ul>
<p>Extending its utility it&rsquo;s up to your imagination and I hope this post has inspired you to create useful generic components.</p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=https://ggp1.github.io/posts/mastering_sql_with_go_p1/>
<span class=title>« Prev Page</span>
<br>
<span>Mastering SQL with Go - Part 1</span>
</a>
<a class=next href=https://ggp1.github.io/posts/applications_containerization/>
<span class=title>Next Page »</span>
<br>
<span>Applications containerization</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 &#183; Gastón Palomeque</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>